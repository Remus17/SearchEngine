



Microcontroller - Wikipedia
document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );
(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Microcontroller","wgTitle":"Microcontroller","wgCurRevisionId":826662386,"wgRevisionId":826662386,"wgArticleId":21017,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Webarchive template wayback links","Articles needing additional references from November 2009","All articles needing additional references","All articles with unsourced statements","Articles with unsourced statements from February 2008","Articles with unsourced statements from June 2010","Articles containing potentially dated statements from 2008","All articles containing potentially dated statements","All articles with vague or ambiguous time","Vague or ambiguous time from August 2016","Articles lacking in-text citations from July 2008","All articles lacking in-text citations","Articles prone to spam from December 2012","Articles with Curlie links","Wikipedia articles with LCCN identifiers","Wikipedia articles with GND identifiers","Wikipedia articles with BNF identifiers","Microcontrollers","Embedded systems"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Microcontroller","wgRelevantArticleId":21017,"wgRequestId":"Wr9jrgpAAEQAABXtaG4AAABV","wgIsProbablyEditable":true,"wgRelevantPageIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgFlaggedRevsParams":{"tags":{}},"wgStableRevisionId":null,"wgWikiEditorEnabledModules":[],"wgBetaFeaturesFeatures":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgPopupsShouldSendModuleToUser":true,"wgPopupsConflictsWithNavPopupGadget":false,"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en","usePageImages":true,"usePageDescriptions":true},"wgPreferredVariant":"en","wgMFExpandAllSectionsUserOption":true,"wgMFEnableFontChanger":true,"wgMFDisplayWikibaseDescriptions":{"search":true,"nearby":true,"watchlist":true,"tagline":false},"wgRelatedArticles":null,"wgRelatedArticlesUseCirrusSearch":true,"wgRelatedArticlesOnlyUseCirrusSearch":false,"wgULSCurrentAutonym":"English","wgNoticeProject":"wikipedia","wgCentralNoticeCookiesToDelete":[],"wgCentralNoticeCategoriesUsingLegacy":["Fundraising","fundraising"],"wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}","wgWikibaseItemId":"Q165678","wgScoreNoteLanguages":{"arabic":"العربية","catalan":"català","deutsch":"Deutsch","english":"English","espanol":"español","italiano":"italiano","nederlands":"Nederlands","norsk":"norsk","portugues":"português","suomi":"suomi","svenska":"svenska","vlaams":"West-Vlams"},"wgScoreDefaultNoteLanguage":"nederlands","wgCentralAuthMobileDomain":false,"wgCodeMirrorEnabled":false,"wgVisualEditorToolbarScrollOffset":0,"wgVisualEditorUnsupportedEditParams":["undo","undoafter","veswitched"],"wgEditSubmitButtonLabelPublish":true});mw.loader.state({"ext.gadget.charinsert-styles":"ready","ext.globalCssJs.user.styles":"ready","ext.globalCssJs.site.styles":"ready","site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","ext.cite.styles":"ready","wikibase.client.init":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.uls.interlanguage":"ready","ext.wikimediaBadges":"ready","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready","ext.globalCssJs.user":"ready","ext.globalCssJs.site":"ready"});mw.loader.implement("user.tokens@1dqfd7l",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["ext.cite.a11y","site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","ext.gadget.teahouse","ext.gadget.ReferenceTooltips","ext.gadget.watchlist-notice","ext.gadget.DRN-wizard","ext.gadget.charinsert","ext.gadget.refToolbar","ext.gadget.extra-toolbar-buttons","ext.gadget.switcher","ext.centralauth.centralautologin","mmv.head","mmv.bootstrap.autostart","ext.popups","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.eventLogging.subscriber","ext.wikimediaEvents","ext.navigationTiming","ext.uls.eventlogger","ext.uls.init","ext.uls.compactlinks","ext.uls.interface","ext.3d","ext.centralNotice.geoIP","ext.centralNotice.startUp","skins.vector.js"]);});























		
		
		
			
			

Microcontroller			
				From Wikipedia, the free encyclopedia				
								
					Jump to:					navigation, 					search
				
				





This article needs additional citations for verification. Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed. (November 2009) (Learn how and when to remove this template message)







The die from an Intel 8742, an 8-bit microcontroller that includes a CPU running at 12 MHz, 128 bytes of RAM, 2048 bytes of EPROM, and I/O in the same chip.






Two ATmega microcontrollers


A microcontroller (or MCU for microcontroller unit) is a small computer on a single integrated circuit. In modern terminology, it is similar to, but less sophisticated than, a system on a chip or SoC; an SoC may include a microcontroller as one of its components. A microcontroller contains one or more CPUs (processor cores) along with memory and programmable input/output peripherals. Program memory in the form of ferroelectric RAM, NOR flash or OTP ROM is also often included on chip, as well as a small amount of RAM. Microcontrollers are designed for embedded applications, in contrast to the microprocessors used in personal computers or other general purpose applications consisting of various discrete chips.
Microcontrollers are used in automatically controlled products and devices, such as automobile engine control systems, implantable medical devices, remote controls, office machines, appliances, power tools, toys and other embedded systems. By reducing the size and cost compared to a design that uses a separate microprocessor, memory, and input/output devices, microcontrollers make it economical to digitally control even more devices and processes. Mixed signal microcontrollers are common, integrating analog components needed to control non-digital electronic systems.
Some microcontrollers may use four-bit words and operate at frequencies as low as 4 kHz, for low power consumption (single-digit milliwatts or microwatts). They will generally have the ability to retain functionality while waiting for an event such as a button press or other interrupt; power consumption while sleeping (CPU clock and most peripherals off) may be just nanowatts, making many of them well suited for long lasting battery applications. Other microcontrollers may serve performance-critical roles, where they may need to act more like a digital signal processor (DSP), with higher clock speeds and power consumption.



Contents


1 History

1.1 Volumes


2 Embedded design

2.1 Interrupts
2.2 Programs
2.3 Other microcontroller features


3 Higher integration
4 Programming environments
5 Types
6 Interrupt latency
7 Microcontroller embedded memory technology

7.1 Data
7.2 Firmware


8 See also
9 References
10 External links



History[edit]
The first microprocessor was the 4-bit Intel 4004 released in 1971, with the Intel 8008 and other more capable microprocessors becoming available over the next several years. However, both processors required external chips to implement a working system, raising total system cost, and making it impossible to economically computerize appliances.
One book credits TI engineers Gary Boone and Michael Cochran with the successful creation of the first microcontroller in 1971. The result of their work was the TMS 1000, which became commercially available in 1974. It combined read-only memory, read/write memory, processor and clock on one chip and was targeted at embedded systems.[1]
Partly in response to the existence of the single-chip TMS 1000,[2] Intel developed a computer system on a chip optimized for control applications, the Intel 8048, with commercial parts first shipping in 1977.[2] It combined RAM and ROM on the same chip. This chip would find its way into over one billion PC keyboards, and other numerous applications. At that time Intel's President, Luke J. Valenter, stated that the microcontroller was one of the most successful in the company's history, and expanded the division's budget over 25%.
Most microcontrollers at this time had concurrent variants. One had an erasable EPROM program memory, with a transparent quartz window in the lid of the package to allow it to be erased by exposure to ultraviolet light, often used for prototyping. The other was either a mask programmed ROM from the manufacturer for large series, or a PROM variant which was only programmable once; sometimes this was signified with the designation OTP, standing for "one-time programmable". The PROM was of identical type of memory as the EPROM, but because there was no way to expose it to ultraviolet light, it could not be erased. The erasable versions required ceramic packages with quartz windows, making them significantly more expensive than the OTP versions, which could be made in lower-cost opaque plastic packages. For the erasable variants, quartz was required, instead of less expensive glass, for its transparency to ultraviolet—glass is largely opaque to UV—but the main cost differentiator was the ceramic package itself.
In 1993, the introduction of EEPROM memory allowed microcontrollers (beginning with the Microchip PIC16x84)[citation needed] to be electrically erased quickly without an expensive package as required for EPROM, allowing both rapid prototyping, and in-system programming. (EEPROM technology had been available prior to this time, but the earlier EEPROM was more expensive and less durable, making it unsuitable for low-cost mass-produced microcontrollers.) The same year, Atmel introduced the first microcontroller using Flash memory, a special type of EEPROM.[3] Other companies rapidly followed suit, with both memory types.
Cost has plummeted over time, with the cheapest 8-bit microcontrollers being available for under 0.25 USD in quantity (thousands) in 2009,[citation needed] and some 32-bit microcontrollers around US$1 for similar quantities.
Nowadays microcontrollers are cheap and readily available for hobbyists, with large online communities around certain processors.
In the future, MRAM could potentially be used in microcontrollers as it has infinite endurance and its incremental semiconductor wafer process cost is relatively low.
Volumes[edit]
In 2002, about 55% of all CPUs sold in the world were 8-bit microcontrollers and microprocessors.[4] Over two billion 8-bit microcontrollers were sold in 1997,[5] and according to Semico, over four billion 8-bit microcontrollers were sold in 2006.[6] More recently, Semico has claimed the MCU market grew 36.5% in 2010 and 12% in 2011.[7]
A typical home in a developed country is likely to have only four general-purpose microprocessors but around three dozen microcontrollers. A typical mid-range automobile has as many as 30 or more microcontrollers. They can also be found in many electrical devices such as washing machines, microwave ovens, and telephones.

Historically, the 8-bit segment has dominated the MCU market [..] 16-bit microcontrollers became the largest volume MCU category in 2011, overtaking 8-bit devices for the first time that year [..] IC Insights believes the makeup of the MCU market will undergo substantial changes in the next five years with 32-bit devices steadily grabbing a greater share of sales and unit volumes. By 2017, 32-bit MCUs are expected to account for 55% of microcontroller sales [..] In terms of unit volumes, 32-bit MCUs are expected account for 38% of microcontroller shipments in 2017, while 16-bit devices will represent 34% of the total, and 4-/8-bit designs are forecast to be 28% of units sold that year. The 32-bit MCU market is expected to grow rapidly due to increasing demand for higher levels of precision in embedded-processing systems and the growth in connectivity using the Internet. [..] In the next few years, complex 32-bit MCUs are expected to account for over 25% of the processing power in vehicles.
— IC Insights, MCU Market on Migration Path to 32-bit and ARM-based Devices[8]

In 2012, following a global crisis – a worst ever annual sales decline and recovery and average sales price year-over-year plunging 17% – the biggest reduction since the 1980s, the average price for a microcontroller was US$0.88 ($0.69 for 4-/8-bit, $0.59 for 16-bit, $1.76 for 32-bit).[8]
In 2012, worldwide sales of 8-bit microcontrollers were around $4 billion, while 4-bit microcontrollers also saw significant sales.[9]
In 2015, 8-bit microcontrollers can be bought for $0.311 (1,000 units),[10] 16-bit for $0.385 (1,000 units),[11] and 32-bit for $0.378 (1,000 units but at $0.35 for 5,000).[12]




A PIC 18F8720 microcontroller in an 80-pin TQFP package.


Embedded design[edit]
A microcontroller can be considered a self-contained system with a processor, memory and peripherals and can be used as an embedded system.[13] The majority of microcontrollers in use today are embedded in other machinery, such as automobiles, telephones, appliances, and peripherals for computer systems.
While some embedded systems are very sophisticated, many have minimal requirements for memory and program length, with no operating system, and low software complexity. Typical input and output devices include switches, relays, solenoids, LED's, small or custom liquid-crystal displays, radio frequency devices, and sensors for data such as temperature, humidity, light level etc. Embedded systems usually have no keyboard, screen, disks, printers, or other recognizable I/O devices of a personal computer, and may lack human interaction devices of any kind.
Interrupts[edit]
Microcontrollers must provide real-time (predictable, though not necessarily fast) response to events in the embedded system they are controlling. When certain events occur, an interrupt system can signal the processor to suspend processing the current instruction sequence and to begin an interrupt service routine (ISR, or "interrupt handler") which will perform any processing required based on the source of the interrupt, before returning to the original instruction sequence. Possible interrupt sources are device dependent, and often include events such as an internal timer overflow, completing an analog to digital conversion, a logic level change on an input such as from a button being pressed, and data received on a communication link. Where power consumption is important as in battery devices, interrupts may also wake a microcontroller from a low-power sleep state where the processor is halted until required to do something by a peripheral event.
Programs[edit]
Typically micro-controller programs must fit in the available on-chip memory, since it would be costly to provide a system with external, expandable memory. Compilers and assemblers are used to convert both high-level and assembly language codes into a compact machine code for storage in the micro-controller's memory. Depending on the device, the program memory may be permanent, read-only memory that can only be programmed at the factory, or it may be field-alterable flash or erasable read-only memory.
Manufacturers have often produced special versions of their micro-controllers in order to help the hardware and software development of the target system. Originally these included EPROM versions that have a "window" on the top of the device through which program memory can be erased by ultraviolet light, ready for reprogramming after a programming ("burn") and test cycle. Since 1998, EPROM versions are rare and have been replaced by EEPROM and flash, which are easier to use (can be erased electronically) and cheaper to manufacture.
Other versions may be available where the ROM is accessed as an external device rather than as internal memory, however these are becoming rare due to the widespread availability of cheap microcontroller programmers.
The use of field-programmable devices on a micro controller may allow field update of the firmware or permit late factory revisions to products that have been assembled but not yet shipped. Programmable memory also reduces the lead time required for deployment of a new product.
Where hundreds of thousands of identical devices are required, using parts programmed at the time of manufacture can be economical. These "mask programmed" parts have the program laid down in the same way as the logic of the chip, at the same time.
A customized micro-controller incorporates a block of digital logic that can be personalized for additional processing capability, peripherals and interfaces that are adapted to the requirements of the application. One example is the AT91CAP from Atmel.
Other microcontroller features[edit]
Microcontrollers usually contain from several to dozens of general purpose input/output pins (GPIO). GPIO pins are software configurable to either an input or an output state. When GPIO pins are configured to an input state, they are often used to read sensors or external signals. Configured to the output state, GPIO pins can drive external devices such as LEDs or motors, often indirectly, through external power electronics.
Many embedded systems need to read sensors that produce analog signals. This is the purpose of the analog-to-digital converter (ADC). Since processors are built to interpret and process digital data, i.e. 1s and 0s, they are not able to do anything with the analog signals that may be sent to it by a device. So the analog to digital converter is used to convert the incoming data into a form that the processor can recognize. A less common feature on some microcontrollers is a digital-to-analog converter (DAC) that allows the processor to output analog signals or voltage levels.
In addition to the converters, many embedded microprocessors include a variety of timers as well. One of the most common types of timers is the programmable interval timer (PIT). A PIT may either count down from some value to zero, or up to the capacity of the count register, overflowing to zero. Once it reaches zero, it sends an interrupt to the processor indicating that it has finished counting. This is useful for devices such as thermostats, which periodically test the temperature around them to see if they need to turn the air conditioner on, the heater on, etc.
A dedicated pulse-width modulation (PWM) block makes it possible for the CPU to control power converters, resistive loads, motors, etc., without using lots of CPU resources in tight timer loops.
A universal asynchronous receiver/transmitter (UART) block makes it possible to receive and transmit data over a serial line with very little load on the CPU. Dedicated on-chip hardware also often includes capabilities to communicate with other devices (chips) in digital formats such as Inter-Integrated Circuit (I²C), Serial Peripheral Interface (SPI), Universal Serial Bus (USB), and Ethernet.[14]
Higher integration[edit]




Die of a PIC12C508 8-bit, fully static, EEPROM/EPROM/ROM-based CMOS microcontroller manufactured by Microchip Technology using a 1200 nanometre process.






Die of a STM32F100C4T6B ARM Cortex-M3 microcontroller with 16 kilobytes flash memory, 24 MHz central processing unit (CPU), motor control and Consumer Electronics Control (CEC) functions. Manufactured by STMicroelectronics.


Micro-controllers may not implement an external address or data bus as they integrate RAM and non-volatile memory on the same chip as the CPU. Using fewer pins, the chip can be placed in a much smaller, cheaper package.
Integrating the memory and other peripherals on a single chip and testing them as a unit increases the cost of that chip, but often results in decreased net cost of the embedded system as a whole. Even if the cost of a CPU that has integrated peripherals is slightly more than the cost of a CPU and external peripherals, having fewer chips typically allows a smaller and cheaper circuit board, and reduces the labor required to assemble and test the circuit board, in addition to tending to decrease the defect rate for the finished assembly.
A micro-controller is a single integrated circuit, commonly with the following features:

central processing unit - ranging from small and simple 4-bit processors to complex 32-bit or 64-bit processors
volatile memory (RAM) for data storage
ROM, EPROM, EEPROM or Flash memory for program and operating parameter storage
discrete input and output bits, allowing control or detection of the logic state of an individual package pin
serial input/output such as serial ports (UARTs)
other serial communications interfaces like I²C, Serial Peripheral Interface and Controller Area Network for system interconnect
peripherals such as timers, event counters, PWM generators, and watchdog
clock generator - often an oscillator for a quartz timing crystal, resonator or RC circuit
many include analog-to-digital converters, some include digital-to-analog converters
in-circuit programming and in-circuit debugging support

This integration drastically reduces the number of chips and the amount of wiring and circuit board space that would be needed to produce equivalent systems using separate chips. Furthermore, on low pin count devices in particular, each pin may interface to several internal peripherals, with the pin function selected by software. This allows a part to be used in a wider variety of applications than if pins had dedicated functions.
Micro-controllers have proved to be highly popular in embedded systems since their introduction in the 1970s.
Some microcontrollers use a Harvard architecture: separate memory buses for instructions and data, allowing accesses to take place concurrently. Where a Harvard architecture is used, instruction words for the processor may be a different bit size than the length of internal memory and registers; for example: 12-bit instructions used with 8-bit data registers.
The decision of which peripheral to integrate is often difficult. The microcontroller vendors often trade operating frequencies and system design flexibility against time-to-market requirements from their customers and overall lower system cost. Manufacturers have to balance the need to minimize the chip size against additional functionality.
Microcontroller architectures vary widely. Some designs include general-purpose microprocessor cores, with one or more ROM, RAM, or I/O functions integrated onto the package. Other designs are purpose built for control applications. A micro-controller instruction set usually has many instructions intended for bit manipulation (bit-wise operations) to make control programs more compact.[15] For example, a general purpose processor might require several instructions to test a bit in a register and branch if the bit is set, where a micro-controller could have a single instruction to provide that commonly required function.
Microcontrollers traditionally do not have a math coprocessor, so floating point arithmetic is performed by software. However, some recent designs do include an FPU and DSP optimized features. An example would be Microchip's PIC32 MIPS based line.
Programming environments[edit]
Microcontrollers were originally programmed only in assembly language, but various high-level programming languages, such as C, Python and JavaScript, are now also in common use to target microcontrollers and embedded systems.[16] These languages are either designed specially for the purpose, or versions of general purpose languages such as the C programming language. Compilers for general purpose languages will typically have some restrictions as well as enhancements to better support the unique characteristics of microcontrollers. Some microcontrollers have environments to aid developing certain types of applications. Microcontroller vendors often make tools freely available to make it easier to adopt their hardware.
Many microcontrollers are so quirky that they effectively require their own non-standard dialects of C, such as SDCC for the 8051, which prevent using standard tools (such as code libraries or static analysis tools) even for code unrelated to hardware features. Interpreters are often used to hide such low level quirks.
Interpreter firmware is also available for some microcontrollers. For example, BASIC on the early microcontrollers Intel 8052;[17] BASIC and FORTH on the Zilog Z8[18] as well as some modern devices. Typically these interpreters support interactive programming.
Simulators are available for some microcontrollers. These allow a developer to analyze what the behavior of the microcontroller and their program should be if they were using the actual part. A simulator will show the internal processor state and also that of the outputs, as well as allowing input signals to be generated. While on the one hand most simulators will be limited from being unable to simulate much other hardware in a system, they can exercise conditions that may otherwise be hard to reproduce at will in the physical implementation, and can be the quickest way to debug and analyze problems.
Recent microcontrollers are often integrated with on-chip debug circuitry that when accessed by an in-circuit emulator (ICE) via JTAG, allow debugging of the firmware with a debugger. A real-time ICE may allow viewing and/or manipulating of internal states while running. A tracing ICE can record executed program and MCU states before/after a trigger point.
Types[edit]
See also: List of common microcontrollers
As of 2008[update], there are several dozen microcontroller architectures and vendors including:

ARM core processors (many vendors)

ARM Cortex-M cores are specifically targeted towards microcontroller applications


Atmel AVR (8-bit), AVR32 (32-bit), and AT91SAM (32-bit)
Cypress Semiconductor's M8C core used in their PSoC (Programmable System-on-Chip)
Freescale ColdFire (32-bit) and S08 (8-bit)
Freescale 68HC11 (8-bit), and others based on the Motorola 6800 family
Intel 8051, also manufactured by NXP Semiconductors, Infineon and many others
Infineon: 8-bit XC800, 16-bit XE166, 32-bit XMC4000 (ARM based Cortex M4F), 32-bit TriCore and, 32-bit Aurix Tricore Bit microcontrollers[19]
MIPS
Microchip Technology PIC, (8-bit PIC16, PIC18, 16-bit dsPIC33 / PIC24), (32-bit PIC32)
NXP Semiconductors LPC1000, LPC2000, LPC3000, LPC4000 (32-bit), LPC900, LPC700 (8-bit)
Parallax Propeller
PowerPC ISE
Rabbit 2000 (8-bit)
Renesas Electronics: RL78 16-bit MCU; RX 32-bit MCU; SuperH; V850 32-bit MCU; H8; R8C 16-bit MCU
Silicon Laboratories Pipelined 8-bit 8051 microcontrollers and mixed-signal ARM-based 32-bit microcontrollers
STMicroelectronics STM8 (8-bit), ST10 (16-bit), STM32 (32-bit), SPC5 (automotive 32-bit)
Texas Instruments TI MSP430 (16-bit), MSP432 (32-bit), C2000 (32-bit)
Toshiba TLCS-870 (8-bit/16-bit)

Many others exist, some of which are used in very narrow range of applications or are more like applications processors than microcontrollers. The microcontroller market is extremely fragmented, with numerous vendors, technologies, and markets. Note that many vendors sell or have sold multiple architectures.
Interrupt latency[edit]
In contrast to general-purpose computers, microcontrollers used in embedded systems often seek to optimize interrupt latency over instruction throughput. Issues include both reducing the latency, and making it be more predictable (to support real-time control).
When an electronic device causes an interrupt, during the context switch the intermediate results (registers) have to be saved before the software responsible for handling the interrupt can run. They must also be restored after that interrupt handler is finished. If there are more processor registers, this saving and restoring process takes more time, increasing the latency. Ways to reduce such context/restore latency include having relatively few registers in their central processing units (undesirable because it slows down most non-interrupt processing substantially), or at least having the hardware not save them all (this fails if the software then needs to compensate by saving the rest "manually"). Another technique involves spending silicon gates on "shadow registers": One or more duplicate registers used only by the interrupt software, perhaps supporting a dedicated stack.
Other factors affecting interrupt latency include:

Cycles needed to complete current CPU activities. To minimize those costs, microcontrollers tend to have short pipelines (often three instructions or less), small write buffers, and ensure that longer instructions are continuable or restartable. RISC design principles ensure that most instructions take the same number of cycles, helping avoid the need for most such continuation/restart logic.
The length of any critical section that needs to be interrupted. Entry to a critical section restricts concurrent data structure access. When a data structure must be accessed by an interrupt handler, the critical section must block that interrupt. Accordingly, interrupt latency is increased by however long that interrupt is blocked. When there are hard external constraints on system latency, developers often need tools to measure interrupt latencies and track down which critical sections cause slowdowns.

One common technique just blocks all interrupts for the duration of the critical section. This is easy to implement, but sometimes critical sections get uncomfortably long.
A more complex technique just blocks the interrupts that may trigger access to that data structure. This is often based on interrupt priorities, which tend to not correspond well to the relevant system data structures. Accordingly, this technique is used mostly in very constrained environments.
Processors may have hardware support for some critical sections. Examples include supporting atomic access to bits or bytes within a word, or other atomic access primitives like the LDREX/STREX exclusive access primitives introduced in the ARMv6 architecture.


Interrupt nesting. Some microcontrollers allow higher priority interrupts to interrupt lower priority ones. This allows software to manage latency by giving time-critical interrupts higher priority (and thus lower and more predictable latency) than less-critical ones.
Trigger rate. When interrupts occur back-to-back, microcontrollers may avoid an extra context save/restore cycle by a form of tail call optimization.

Lower end microcontrollers tend to support fewer interrupt latency controls than higher end ones.
Microcontroller embedded memory technology[edit]
Since the emergence of microcontrollers, many different memory technologies have been used. Almost all microcontrollers have at least two different kinds of memory, a non-volatile memory for storing firmware and a read-write memory for temporary data.
Data[edit]
From the earliest microcontrollers to today, six-transistor SRAM is almost always used as the read/write working memory, with a few more transistors per bit used in the register file. FRAM or MRAM could potentially replace it as it is 4 to 10 times denser which would make it more cost effective.
In addition to the SRAM, some microcontrollers also have internal EEPROM for data storage; and even ones that do not have any (or not enough) are often connected to external serial EEPROM chip (such as the BASIC Stamp) or external serial flash memory chip.
A few recent[when?] microcontrollers beginning in 2003 have "self-programmable" flash memory.[3]
Firmware[edit]
The earliest microcontrollers used mask ROM to store firmware. Later microcontrollers (such as the early versions of the Freescale 68HC11 and early PIC microcontrollers) had EPROM memory, which used a translucent window to allow erasure via UV light, while production versions had no such window, being OTP (one-time-programmable). Firmware updates were equivalent to replacing the microcontroller itself, thus many products were not upgradeable.
The Microchip PIC16C84, introduced in 1993,[20] was the first microcontroller to use EEPROM to store firmware. In the same year, Atmel introduced the first microcontroller using NOR Flash memory to store firmware.[3] Today's microcontrollers almost exclusively use flash memory, with a few models using FRAM, and some ultra-low-cost parts still use OTP or Mask-ROM.
See also[edit]


Electronics portal



List of common microcontrollers
List of Wi-Fi microcontrollers
List of open-source hardware projects
Microbotics
Programmable logic controller
Single-board microcontroller

References[edit]






This article includes a list of references, but its sources remain unclear because it has insufficient inline citations. Please help to improve this article by introducing more precise citations. (July 2008) (Learn how and when to remove this template message)






^ Augarten, Stan (1983). The Most Widely Used Computer on a Chip: The TMS 1000. State of the Art: A Photographic History of the Integrated Circuit. New Haven and New York: Ticknor & Fields. ISBN 0-89919-195-9. Retrieved 2009-12-23. 
^ a b "Oral History Panel on the Development and Promotion of the Intel 8048 Microcontroller" (PDF). Computer History Museum Oral History, 2008. p. 4. Retrieved 2016-04-04. 
^ a b c "Atmel's Self-Programming Flash Microcontrollers" (PDF). 2012-01-24. Retrieved 2008-10-25.  by Odd Jostein Svendsli 2003
^ Jim Turley. "The Two Percent Solution" 2002.
^ Tom Cantrell "Microchip on the March" Archived 2007-09-27 at the Wayback Machine.. Circuit Cellar. 1998.
^ http://www.semico.com
^ Momentum Carries MCUs Into 2011 http://semico.com/content/momentum-carries-mcus-2011
^ a b "MCU Market on Migration Path to 32-bit and ARM-based Devices". April 25, 2013. It typically takes a global economic recession to upset the diverse MCU marketplace, and that’s exactly what occurred in 2009, when the microcontroller business suffered its worst-ever annual sales decline of 22% to $11.1 billion. 
^ Bill Giovino. "Zilog Buys Microcontroller Product Lines from Samsung". 2013.
^ http://www.mouser.com/ProductDetail/Silicon-Labs/EFM8BB10F2G-A-QFN20/?qs=sGAEpiMZZMu9ReDVvI6ax9sqO0qrXlDW4ZuhKcnb2c%252bQvyUXU1UbuQ%3d%3d
^ http://www.mouser.com/ProductDetail/Texas-Instruments/MSP430G2001IPW14R/?qs=sGAEpiMZZMvfhsTlJjecML5mLnp8Cec4esZ6%2f1aK7FQ%3d
^ http://www.mouser.com/ProductDetail/Cypress-Semiconductor/CY8C4013SXI-400/?qs=sGAEpiMZZMuI9neUTtPr752e7iT1qQqS4inl2jxeWgxWqjKLOdzceQ%3d%3d
^ Heath, Steve (2003). Embedded systems design. EDN series for design engineers (2 ed.). Newnes. pp. 11–12. ISBN 9780750655460. 
^ David Harris & Sarah Harris (2012). Digital Design and Computer Architecture, Second Edition, p. 515. Morgan Kaufmann. ISBN 0123944244.
^ Easy Way to build a microcontroller project
^ Mazzei, Daniele; Montelisciani, Gabriele; Baldi, Giacomo; Fantoni, Gualtiero (2015). Changing the programming paradigm for the embedded in the IoT domain. Internet of Things (WF-IoT), 2015 IEEE 2nd World Forum on. Milan: IEEE. pp. 239–244. doi:10.1109/WF-IoT.2015.7389059. 
^ "8052-Basic Microcontrollers" by Jan Axelson 1994
^ Edwards, Robert (1987). "Optimizing the Zilog Z8 Forth Microcontroller for Rapid Prototyping" (PDF). Martin Marietta: 3. Retrieved 9 December 2012. 
^ www.infineon.com/mcu
^ Microchip unveils PIC16C84, a reprogrammable EEPROM-based 8-bit microcontroller 1993



External links[edit]

Find more aboutMicrocontrollerat Wikipedia's sister projects

Definitions from Wiktionary
Media from Wikimedia Commons
Textbooks from Wikibooks
Learning resources from Wikiversity



Microcontroller at Curlie (based on DMOZ)







v
t
e


Microcontrollers



Main



Single-board microcontroller
Special function register





Architectures



68000
8051
ARM
AVR
PIC
RISC-V





Families




4-bit



Am2900
MARC4
S1C6x
TLCS-47
TMS1000
μCOM-4





8-bit



6800

68HC05
68HC08
68HC11
S08
RS08


6502

65C02
MELPS 740


78K
8048
8051

XC800


AVR
COP8
H8
PIC10/12/16/17/18
ST6/ST7

STM8


Z8
Z80

eZ80
Rabbit 2000
TLCS-870







16-bit



68HC12/16
C166
CR16/C
H8S
MSP430
PIC24/dsPIC
R8C
RL78
TLCS-900
Z8000





32-bit



Am29000
ARM/Cortex-M

LPC


AVR32
CRX
FR

FR-V


H8SX
M32R
68000

ColdFire


PIC32
PowerPC

MPC5xx


Propeller
STM32
TLCS-900
TriCore
V850
RX
Z80000





64-bit



PowerPC64








Interfaces




Programming



In-circuit serial programming (ICSP)
In-system programming (ISP)
Program and Debug Interface (PDI)
High-voltage serial programming (HVSP)
High voltage parallel programming (HVPP)
Bootloader
ROM
aWire





Debugging



Nexus (standard)
Joint Test Action Group (JTAG)

debugWIRE (Atmel)


In-circuit debugging (ICD)
In-circuit emulator (ICE)
In-target probe (ITP)








Simulators



gpsim





Lists



List of common microcontrollers
By manufacturer

Intel
NXP/Freescale
Renesas Electronics


List of Wi-Fi microcontrollers





See also



Embedded system
Programmable logic controller












v
t
e


CPU technologies



Architecture



Turing machine
Post–Turing machine
Universal Turing machine
Quantum Turing machine
Belt machine
Stack machine
Register machine
Counter machine
Pointer machine
Random access machine
Random access stored program machine
Finite-state machine
Queue automaton
Von Neumann
Harvard (modified)
Dataflow
TTA
Cellular
Artificial neural network

Machine learning
Deep learning
Neural processing unit (NPU)


Convolutional neural network
Load/store architecture
Register memory architecture
Endianness
FIFO
Zero-copy
NUMA
HUMA
HSA
Mobile computing
Surface computing
Wearable computing
Heterogeneous computing
Parallel computing
Concurrent computing
Distributed computing
Cloud computing
Amorphous computing
Ubiquitous computing
Fabric computing
Cognitive computing
Unconventional computing
Hypercomputation
Quantum computing
Adiabatic quantum computing
Linear optical quantum computing
Reversible computing
Reverse computation
Reconfigurable computing
Optical computing
Ternary computer
Analogous computing
Mechanical computing
Hybrid computing
Digital computing
DNA computing
Peptide computing
Chemical computing
Organic computing
Wetware computing
Neuromorphic computing
Symmetric multiprocessing (SMP)
Asymmetric multiprocessing (AMP)
Cache hierarchy
Memory hierarchy





ISA types



ASIP
CISC
RISC
EDGE (TRIPS)
VLIW (EPIC)
MISC
OISC
NISC
ZISC
Comparison





ISAs



x86
z/Architecture
ARM
MIPS
Power Architecture (PowerPC)
SPARC
Mill
Itanium (IA-64)
Alpha
Prism
SuperH
V850
Clipper
VAX
Unicore
PA-RISC
MicroBlaze
RISC-V





Word size



1-bit
2-bit
4-bit
8-bit
9-bit
10-bit
12-bit
15-bit
16-bit
18-bit
22-bit
24-bit
25-bit
26-bit
27-bit
31-bit
32-bit
33-bit
34-bit
36-bit
39-bit
40-bit
48-bit
50-bit
60-bit
64-bit
128-bit
256-bit
512-bit
Variable





Execution



Instruction pipelining

Bubble
Operand forwarding


Out-of-order execution

Register renaming


Speculative execution

Branch predictor
Memory dependence prediction


Hazards





Parallel level



Bit

Bit-serial
Word


Instruction
Pipelining

Scalar
Superscalar


Task

Thread
Process


Data

Vector


Memory





Multithreading



Temporal
Simultaneous (SMT) (Hyper-threading)
Speculative (SpMT)
Preemptive
Cooperative
Clustered Multi-Thread (CMT)
Hardware scout





Flynn's taxonomy



SISD
SIMD (SWAR)
SIMT
MISD
MIMD

SPMD


Addressing mode





CPU performance



Instructions per second (IPS)
Instructions per clock (IPC)
Cycles per instruction (CPI)
Floating-point operations per second (FLOPS)
Transactions per second (TPS)
Synaptic Updates Per Second (SUPS)
Performance per watt
Orders of magnitude (computing)
Cache performance measurement and metric





Core count



Single-core processor
Multi-core processor
Manycore processor





Types



Central processing unit (CPU)
GPGPU
AI accelerator
Vision processing unit (VPU)
Vector processor
Barrel processor
Stream processor
Digital signal processor (DSP)
I/O processor/DMA controller
Network processor
Baseband processor
Physics processing unit (PPU)
Coprocessor
Secure cryptoprocessor
ASIC
FPGA
FPOA
CPLD
Microcontroller
Microprocessor
Mobile processor
Notebook processor
Ultra-low-voltage processor
Multi-core processor
Manycore processor
Tile processor
Multi-chip module (MCM)
Chip stack multi-chip modules
System on a chip (SoC)
Multiprocessor system-on-chip (MPSoC)
Programmable System-on-Chip (PSoC)
Network on a chip (NoC)





Components



Execution unit (EU)
Arithmetic logic unit (ALU)
Address generation unit (AGU)
Floating-point unit (FPU)
Load-store unit (LSU)
Branch predictor
Unified Reservation Station
Barrel shifter
Uncore
Sum addressed decoder (SAD)
Front-side bus
Back-side bus
Northbridge (computing)
Southbridge (computing)
Adder (electronics)
Binary multiplier
Binary decoder
Address decoder
Multiplexer
Demultiplexer
Registers
Cache
Memory management unit (MMU)
Input–output memory management unit (IOMMU)
Integrated Memory Controller (IMC)
Power Management Unit (PMU)
Translation lookaside buffer (TLB)
Stack engine
Register file
Processor register
Hardware register
Memory buffer register (MBR)
Program counter
Microcode ROM
Datapath
Control unit
Instruction unit
Re-order buffer
Data buffer
Write buffer
Coprocessor
Electronic switch
Electronic circuit
Integrated circuit
Three-dimensional integrated circuit
Boolean circuit
Digital circuit
Analog circuit
Mixed-signal integrated circuit
Power management integrated circuit
Quantum circuit
Logic gate

Combinational logic
Sequential logic
Emitter-coupled logic (ECL)
Transistor–transistor logic (TTL)
Glue logic


Quantum gate
Gate array
Counter (digital)
Bus (computing)
Semiconductor device
Clock rate
CPU multiplier
Vision chip
Memristor





Power
management



APM
ACPI
Dynamic frequency scaling
Dynamic voltage scaling
Clock gating





Hardware
security



Non-executable memory (NX bit)
Memory Protection Extensions (Intel MPX)
Intel Secure Key
Hardware restriction (firmware)
Software Guard Extensions (Intel SGX)
Trusted Execution Technology
Trusted Platform Module (TPM)
Secure cryptoprocessor
Hardware security module
Hengzhi chip





Related



History of general-purpose CPUs












v
t
e


Computer sizes




Classes of computers



Microcomputer,
personal
computer




Stationary



Workstation
Desktop
Home
Personal supercomputer
SFF

Nettop


Plug
Portable

Tabletop


Game arcade cabinet

System board


Home console
Microconsole
Interactive kiosk
Smart TV
Smart speaker





Mobile




Laptop



Desktop replacement
2-in-1
Subnotebook

Netbook
Smartbook
Ultrabook


Ultra-mobile PC





Tablet



Ultra-mobile PC
2-in-1
Mobile Internet device
Tabletop
Phablet





Information
appliance



Handheld PC

Palm-size PC
Pocket PC
Pocket computer
Palmtop PC


PDA

Electronic organizer
EDA


Mobile phone

Feature phone
Smartphone

Phablet




PMP

DAP


E-reader
Handheld game console
Portable/Mobile data terminal





Calculator



Scientific
Programmable
Graphing





Wearable



Digital wristwatch

Calculator watch
Smartwatch


Smartglasses
Smart ring











Midrange



Server
Minicomputer
Supermini





Large



Super
Mainframe
Minisuper





Others



Microcontroller
Nanocomputer
Pizza box form factor
Single-board computer
Smartdust
Wireless sensor network









Authority control



LCCN: sh2008020006
GND: 4127438-6
BNF: cb13319620r (data)












					
						Retrieved from "https://en.wikipedia.org/w/index.php?title=Microcontroller&oldid=826662386"					
				Categories: MicrocontrollersEmbedded systemsHidden categories: Webarchive template wayback linksArticles needing additional references from November 2009All articles needing additional referencesAll articles with unsourced statementsArticles with unsourced statements from February 2008Articles with unsourced statements from June 2010Articles containing potentially dated statements from 2008All articles containing potentially dated statementsAll articles with vague or ambiguous timeVague or ambiguous time from August 2016Articles lacking in-text citations from July 2008All articles lacking in-text citationsArticles prone to spam from December 2012Articles with Curlie linksWikipedia articles with LCCN identifiersWikipedia articles with GND identifiersWikipedia articles with BNF identifiers				
							
		
		
			Navigation menu
			
									
						Personal tools
						
							Not logged inTalkContributionsCreate accountLog in						
					
									
										
						Namespaces
						
							ArticleTalk						
					
										
												
						
							Variants
						
						
							
															
						
					
									
				
										
						Views
						
							ReadEditView history						
					
										
						
						More
						
							
															
						
					
										
						
							Search
						
						
							
															
						
					
									
			
			
				
						
			Navigation
			
								
					Main pageContentsFeatured contentCurrent eventsRandom articleDonate to WikipediaWikipedia store				
							
		
			
			Interaction
			
								
					HelpAbout WikipediaCommunity portalRecent changesContact page				
							
		
			
			Tools
			
								
					What links hereRelated changesUpload fileSpecial pagesPermanent linkPage informationWikidata itemCite this page				
							
		
			
			Print/export
			
								
					Create a bookDownload as PDFPrintable version				
							
		
			
			In other projects
			
								
					Wikimedia Commons				
							
		
			
			Languages
			
								
					AfrikaansالعربيةAzərbaycancaБългарскиBosanskiCatalàČeštinaDanskDeutschEestiΕλληνικάEspañolEuskaraفارسیFrançaisGalego한국어हिन्दीBahasa IndonesiaÍslenskaItalianoעבריתBasa Jawaಕನ್ನಡLatviešuMagyarМакедонскиമലയാളംमराठीBahasa Melayuမြန်မာဘာသာNederlands日本語NorskNorsk nynorskਪੰਜਾਬੀPolskiPortuguêsRomânăРусскийScotsShqipසිංහලSimple EnglishSlovenčinaSlovenščinaСрпски / srpskiSrpskohrvatski / српскохрватскиSuomiSvenskaதமிழ்ไทยTürkçeУкраїнськаTiếng Việt中文				
				Edit links			
		
				
		
				
						
								 This page was last edited on 20 February 2018, at 10:21.
								Text is available under the Creative Commons Attribution-ShareAlike License;
additional terms may apply.  By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.
							
						
								Privacy policy
								About Wikipedia
								Disclaimers
								Contact Wikipedia
								Developers
								Cookie statement
								Mobile view
							
										
										
											
										
											
									
						
		
		(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.412","walltime":"0.546","ppvisitednodes":{"value":2422,"limit":1000000},"ppgeneratednodes":{"value":0,"limit":1500000},"postexpandincludesize":{"value":145340,"limit":2097152},"templateargumentsize":{"value":3920,"limit":2097152},"expansiondepth":{"value":16,"limit":40},"expensivefunctioncount":{"value":7,"limit":500},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":15096,"limit":5000000},"entityaccesscount":{"value":1,"limit":400},"timingprofile":["100.00%  379.769      1 -total"," 31.51%  119.658      1 Template:Reflist"," 12.37%   46.970      3 Template:Fix"," 11.79%   44.766      1 Template:Refimprove","  9.89%   37.574      2 Template:Cite_book","  9.89%   37.567      7 Template:Navbox","  9.83%   37.346      2 Template:Citation_needed","  9.62%   36.552      2 Template:Ambox","  7.30%   27.741      3 Template:Delink","  6.19%   23.492      1 Template:Authority_control"]},"scribunto":{"limitreport-timeusage":{"value":"0.149","limit":"10.000"},"limitreport-memusage":{"value":5182239,"limit":52428800}},"cachereport":{"origin":"mw1251","timestamp":"20180331102127","ttl":1900800,"transientcontent":false}}});});(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":105,"wgHostname":"mw1273"});});
	

