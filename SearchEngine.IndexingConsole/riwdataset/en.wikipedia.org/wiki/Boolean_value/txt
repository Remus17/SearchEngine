



Boolean data type - Wikipedia
document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );
(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Boolean_data_type","wgTitle":"Boolean data type","wgCurRevisionId":832880502,"wgRevisionId":832880502,"wgArticleId":1162065,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Articles with example ALGOL 68 code","Boolean algebra","Data types","Primitive types"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Boolean_data_type","wgRelevantArticleId":1162065,"wgRequestId":"Wr-6nApAICIAAAetdcgAAABH","wgIsProbablyEditable":true,"wgRelevantPageIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRedirectedFrom":"Boolean_value","wgFlaggedRevsParams":{"tags":{}},"wgStableRevisionId":null,"wgWikiEditorEnabledModules":[],"wgBetaFeaturesFeatures":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgPopupsShouldSendModuleToUser":true,"wgPopupsConflictsWithNavPopupGadget":false,"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en","usePageImages":true,"usePageDescriptions":true},"wgPreferredVariant":"en","wgMFExpandAllSectionsUserOption":true,"wgMFEnableFontChanger":true,"wgMFDisplayWikibaseDescriptions":{"search":true,"nearby":true,"watchlist":true,"tagline":false},"wgRelatedArticles":null,"wgRelatedArticlesUseCirrusSearch":true,"wgRelatedArticlesOnlyUseCirrusSearch":false,"wgULSCurrentAutonym":"English","wgNoticeProject":"wikipedia","wgCentralNoticeCookiesToDelete":[],"wgCentralNoticeCategoriesUsingLegacy":["Fundraising","fundraising"],"wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}","wgInternalRedirectTargetUrl":"/wiki/Boolean_data_type","wgWikibaseItemId":"Q520777","wgScoreNoteLanguages":{"arabic":"العربية","catalan":"català","deutsch":"Deutsch","english":"English","espanol":"español","italiano":"italiano","nederlands":"Nederlands","norsk":"norsk","portugues":"português","suomi":"suomi","svenska":"svenska","vlaams":"West-Vlams"},"wgScoreDefaultNoteLanguage":"nederlands","wgCentralAuthMobileDomain":false,"wgCodeMirrorEnabled":false,"wgVisualEditorToolbarScrollOffset":0,"wgVisualEditorUnsupportedEditParams":["undo","undoafter","veswitched"],"wgEditSubmitButtonLabelPublish":true});mw.loader.state({"ext.gadget.charinsert-styles":"ready","ext.globalCssJs.user.styles":"ready","ext.globalCssJs.site.styles":"ready","site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","ext.cite.styles":"ready","ext.math.styles":"ready","wikibase.client.init":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.uls.interlanguage":"ready","ext.wikimediaBadges":"ready","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready","ext.globalCssJs.user":"ready","ext.globalCssJs.site":"ready"});mw.loader.implement("user.tokens@1dqfd7l",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["mediawiki.action.view.redirect","ext.cite.a11y","ext.math.scripts","site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","ext.gadget.teahouse","ext.gadget.ReferenceTooltips","ext.gadget.watchlist-notice","ext.gadget.DRN-wizard","ext.gadget.charinsert","ext.gadget.refToolbar","ext.gadget.extra-toolbar-buttons","ext.gadget.switcher","ext.centralauth.centralautologin","ext.popups","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.eventLogging.subscriber","ext.wikimediaEvents","ext.navigationTiming","ext.uls.eventlogger","ext.uls.init","ext.uls.compactlinks","ext.uls.interface","ext.3d","ext.centralNotice.geoIP","ext.centralNotice.startUp","skins.vector.js"]);});






















		
		
		
			
			

Boolean data type			
				From Wikipedia, the free encyclopedia				  (Redirected from Boolean value)
								
					Jump to:					navigation, 					search
				
				In computer science, the Boolean data type is a data type, having two values (usually denoted true and false), intended to represent the truth values of logic and Boolean algebra. It is named after George Boole, who first defined an algebraic system of logic in the mid 19th century. The Boolean data type is primarily associated with conditional statements, which allow different actions and change control flow depending on whether a programmer-specified Boolean condition evaluates to true or false. It is a special case of a more general logical data type; logic need not always be Boolean.



Contents


1 Generalities
2 ALGOL and the built-in boolean type
3 Fortran
4 Lisp and Scheme
5 Pascal, Ada, and Haskell
6 C, C++, Objective-C, AWK
7 Perl and Lua
8 Tcl
9 Python, Ruby, and JavaScript
10 SQL
11 See also
12 References



Generalities[edit]
In programming languages with a built-in Boolean data type, such as Pascal and Java, the comparison operators such as > and ≠ are usually defined to return a Boolean value. Conditional and iterative commands may be defined to test Boolean-valued expressions.
Languages with no explicit Boolean data type, like C90 and Lisp, may still represent truth values by some other data type. Common Lisp uses an empty list for false, and any other value for true. The C programming language uses an integer type, where relational expressions like i > j and logical expressions connected by && and || are defined to have value 1 if true and 0 if false, whereas the test parts of if, while, for, etc., treat any non-zero value as true.[1][2] Indeed, a Boolean variable may be regarded (and implemented) as a numerical variable with one binary digit (bit), which can store only two values. The implementation of Booleans in computers are most likely represented as a full word, rather than a bit; this is usually due to the ways computers transfer blocks of information.
Most programming languages, even those with no explicit Boolean type, have support for Boolean algebraic operations such as conjunction (AND, &, *), disjunction (OR, |, +), equivalence (EQV, =, ==), exclusive or/non-equivalence (XOR, NEQV, ^, !=), and negation (NOT, ~, !).
In some languages, like Ruby, Smalltalk, and Alice the true and false values belong to separate classes, i.e., True and False, respectively, so there is no one Boolean type.
In SQL, which uses a three-valued logic for explicit comparisons because of its special treatment of Nulls, the Boolean data type (introduced in SQL:1999) is also defined to include more than two truth values, so that SQL Booleans can store all logical values resulting from the evaluation of predicates in SQL. A column of Boolean type can also be restricted to just TRUE and FALSE though.
ALGOL and the built-in boolean type[edit]
One of the earliest programming languages to provide an explicit boolean data type was ALGOL 60 (1960) with values true and false and logical operators denoted by symbols '
  
    
      
        ∧
      
    
    {\displaystyle \wedge }
  
' (and), '
  
    
      
        ∨
      
    
    {\displaystyle \vee }
  
' (or), '
  
    
      
        ⊃
      
    
    {\displaystyle \supset }
  
' (implies), '
  
    
      
        ≡
      
    
    {\displaystyle \equiv }
  
' (equivalence), and '
  
    
      
        ¬
      
    
    {\displaystyle \neg }
  
' (not). Due to input device and character set limits on many computers of the time, however, most compilers used alternative representations for many of the operators, such as AND or 'AND'.
This approach with boolean as a built-in (either primitive or otherwise predefined) data type was adopted by many later programming languages, such as Simula 67 (1967), ALGOL 68 (1970),[3] Pascal (1970), Ada (1980), Java (1995), and C# (2000), among others.
Fortran[edit]
The first version of FORTRAN (1957) and its successor FORTRAN II (1958) had no logical values or operations; even the conditional IF statement took an arithmetic expression and branched to one of three locations according to its sign; see arithmetic IF. FORTRAN IV (1962), however, followed the ALGOL 60 example by providing a Boolean data type (LOGICAL), truth literals (.TRUE. and .FALSE.), Boolean-valued numeric comparison operators (.EQ., .GT., etc.), and logical operators (.NOT., .AND., .OR.). In FORMAT statements, a specific control character ('L') was provided for the parsing or formatting of logical values.[4]
Lisp and Scheme[edit]
The language Lisp (1958) never had a built-in Boolean data type. Instead, conditional constructs like cond assume that the logical value false is represented by the empty list (), which is defined to be the same as the special atom nil or NIL; whereas any other s-expression is interpreted as true. For convenience, most modern dialects of Lisp predefine the atom t to have value t, so that t can be used as a mnemonic notation for true.
This approach (any value can be used as a Boolean value) was retained in most Lisp dialects (Common Lisp, Scheme, Emacs Lisp), and similar models were adopted by many scripting languages, even ones having a distinct Boolean type or Boolean values; although which values are interpreted as false and which are true vary from language to language. In Scheme, for example, the false value is an atom distinct from the empty list, so the latter is interpreted as true.
Pascal, Ada, and Haskell[edit]
The language Pascal (1970) introduced the concept of programmer-defined enumerated types. A built-in Boolean data type was then provided as a predefined enumerated type with values FALSE and TRUE. By definition, all comparisons, logical operations, and conditional statements applied to and/or yielded Boolean values. Otherwise, the Boolean type had all the facilities which were available for enumerated types in general, such as ordering and use as indices. In contrast, converting between Booleans and integers (or any other types) still required explicit tests or function calls, as in ALGOL 60. This approach (Boolean is an enumerated type) was adopted by most later languages which had enumerated types, such as Modula, Ada, and Haskell.
C, C++, Objective-C, AWK[edit]
Initial implementations of the language C (1972) provided no Boolean type, and to this day Boolean values are commonly represented by integers (ints) in C programs. The comparison operators (>, ==, etc.) are defined to return a signed integer (int) result, either 0 (for false) or 1 (for true). Logical operators (&&, ||, !, etc.) and condition-testing statements (if, while) assume that zero is false and all other values are true.
After enumerated types (enums) were added to the American National Standards Institute version of C, ANSI C (1989), many C programmers got used to defining their own Boolean types as such, for readability reasons. However, enumerated types are equivalent to integers according to the language standards; so the effective identity between Booleans and integers is still valid for C programs.
Standard C (since C99) provides a boolean type, called _Bool. By including the header stdbool.h, one can use the more intuitive name bool and the constants true and false. The language guarantees that any two true values will compare equal (which was impossible to achieve before the introduction of the type). Boolean values still behave as integers, can be stored in integer variables, and used anywhere integers would be valid, including in indexing, arithmetic, parsing, and formatting. This approach (Boolean values are just integers) has been retained in all later versions of C.
C++ has a separate Boolean data type bool, but with automatic conversions from scalar and pointer values that are very similar to those of C. This approach was adopted also by many later languages, especially by some scripting languages such as AWK.
Objective-C also has a separate Boolean data type BOOL, with possible values being YES or NO, equivalents of true and false respectively.[5] Also, in Objective-C compilers that support C99, C's _Bool type can be used, since Objective-C is a superset of C.
Perl and Lua[edit]
Perl has no boolean data type. Instead, any value can behave as boolean in boolean context (condition of if or while statement, argument of && or ||, etc.). The number 0, the strings "0" and "", the empty list (), and the special value undef evaluate to false.[6] All else evaluates to true.
Lua has a boolean data type, but non-boolean value can also behave as boolean. The non-value nil evaluate to false, whereas every other data type always evaluates to true, regardless of value.
Tcl[edit]
Tcl has no separate Boolean type. Like in C, the integers 0 (false) and 1 (true - in fact any nonzero integer) are used.[7]
Examples of coding:
set v 1 if { $v } { puts "V is 1 or true" }
The above will show "V is 1 or true" since the expression evaluates to '1'
set v "" if { $v } ....
The above will render an error as variable 'v' cannot be evaluated as '0' or '1'
Python, Ruby, and JavaScript[edit]
Python, from version 2.3 forward, has a bool type which is a subclass of int, the standard integer type.[8] It has two possible values: True and False, which are special versions of 1 and 0 respectively and behave as such in arithmetic contexts. Also, a numeric value of zero (integer or fractional), the null value (None), the empty string, and empty containers (i.e. lists, sets, etc.) are considered Boolean false; all other values are considered Boolean true by default.[9] Classes can define how their instances are treated in a Boolean context through the special method __nonzero__ (Python 2) or __bool__ (Python 3). For containers, __len__ (the special method for determining the length of containers) is used if the explicit Boolean conversion method is not defined.
In Ruby, in contrast, only nil (Ruby's null value) and a special false object are false, all else (including the integer 0 and empty arrays) is true.
In JavaScript, the empty string (""), null, undefined, NaN, +0, −0 and false[10] are sometimes called falsy, and their complement, truthy, to distinguish between strictly type-checked and coerced Booleans.[11] Languages such as PHP also use this approach.
SQL[edit]
The SQL:1999 standard introduced a BOOLEAN data type as an optional feature (T031). When restricted by a NOT NULL constraint, a SQL BOOLEAN behaves like Booleans in other languages. However, in SQL the BOOLEAN type is nullable by default like all other SQL data types, meaning it can have the special null value also. Although the SQL standard defines three literals for the BOOLEAN type – TRUE, FALSE, and UNKNOWN – it also says that the NULL BOOLEAN and UNKNOWN "may be used interchangeably to mean exactly the same thing".[12][13] This has caused some controversy because the identification subjects UNKNOWN to the equality comparison rules for NULL. More precisely UNKNOWN = UNKNOWN is not TRUE but UNKNOWN/NULL.[14] As of 2012 few major SQL systems implement the T031 feature.[15] PostgreSQL is a notable exception, although it implements no UNKNOWN literal; NULL can be used instead.[16]
See also[edit]

true and false (commands), for shell scripting
Shannon's expansion
stdbool.h, C99 definitions for boolean
Boolean differential calculus







v
t
e


Data types



Uninterpreted



Bit
Byte
Trit
Tryte
Word
Bit array





Numeric



Arbitrary-precision or bignum
Complex
Decimal
Fixed point
Floating point

Double precision
Extended precision
Half precision
Long double
Minifloat
Octuple precision
Quadruple precision
Single precision


Integer

signedness


Interval
Rational





Pointer



Address

physical
virtual


Reference





Text



Character
String

null-terminated







Composite



Algebraic data type

generalized


Array
Associative array
Class
Dependent
Equality
Inductive
List
Object

metaobject


Option type
Product
Record
Set
Union

tagged







Other



Boolean
Bottom type
Collection
Enumerated type
Exception
Function type
Opaque data type
Recursive data type
Semaphore
Stream
Top type
Type class
Unit type
Void





Related
topics



Abstract data type
Data structure
Generic
Kind

metaclass


Parametric polymorphism
Primitive data type
Protocol

interface


Subtyping
Type constructor
Type conversion
Type system
Type theory






See also platform-dependent and independent units of information




References[edit]


^ Kernighan, Brian W; Ritchie, Dennis M (1978). The C Programming Language (1st ed.). Englewood Cliffs, NJ: Prentice Hall. p. 41. ISBN 0-13-110163-3. 
^ Plauger, PJ; Brodie, Jim (1992) [1989]. ANSI and ISO Standard C Programmer's reference. Microsoft Press. pp. 86–93. ISBN 1-55615-359-7. 
^ "Report on the Algorithmic Language ALGOL 68, Section 10.2.2" (PDF). August 1968. Retrieved 30 April 2007. 
^ Digital Equipment Corporation, DECSystem10 FORTRAN IV Programmers Reference Manual. Reprinted in Mathematical Languages Handbook. Online version accessed 2011-11-16.
^ https://developer.apple.com/library/ios/#documentation/cocoa/conceptual/ProgrammingWithObjectiveC/FoundationTypesandCollections/FoundationTypesandCollections.html
^ "perlsyn - Perl Syntax / Truth and Falsehood". Retrieved 10 September 2013. 
^ "PEP 285 -- Adding a bool type". 4 May 2011. Retrieved 28 March 2018. 
^ Van Rossum, Guido (3 April 2002). "PEP 285 -- Adding a bool type". Retrieved 15 May 2013. 
^ "Expressions". Python v3.3.2 documentation. Retrieved 15 May 2013. 
^ "ECMAScript Language Specification" (PDF). p. 43. 
^ "The Elements of JavaScript Style". Douglas Crockford. Retrieved 5 March 2011. 
^ C. Date (2011). SQL and Relational Theory: How to Write Accurate SQL Code. O'Reilly Media, Inc. p. 83. ISBN 978-1-4493-1640-2. 
^ ISO/IEC 9075-2:2011 §4.5
^ Martyn Prigmore (2007). Introduction to Databases With Web Applications. Pearson Education Canada. p. 197. ISBN 978-0-321-26359-9. 
^ Troels Arvin, Survey of BOOLEAN data type implementation
^ http://www.postgresql.org/docs/current/static/datatype-boolean.html








					
						Retrieved from "https://en.wikipedia.org/w/index.php?title=Boolean_data_type&oldid=832880502"					
				Categories: Boolean algebraData typesPrimitive typesHidden categories: Articles with example ALGOL 68 code				
							
		
		
			Navigation menu
			
									
						Personal tools
						
							Not logged inTalkContributionsCreate accountLog in						
					
									
										
						Namespaces
						
							ArticleTalk						
					
										
												
						
							Variants
						
						
							
															
						
					
									
				
										
						Views
						
							ReadEditView history						
					
										
						
						More
						
							
															
						
					
										
						
							Search
						
						
							
															
						
					
									
			
			
				
						
			Navigation
			
								
					Main pageContentsFeatured contentCurrent eventsRandom articleDonate to WikipediaWikipedia store				
							
		
			
			Interaction
			
								
					HelpAbout WikipediaCommunity portalRecent changesContact page				
							
		
			
			Tools
			
								
					What links hereRelated changesUpload fileSpecial pagesPermanent linkPage informationWikidata itemCite this page				
							
		
			
			Print/export
			
								
					Create a bookDownload as PDFPrintable version				
							
		
			
			Languages
			
								
					العربيةAzərbaycancaБългарскиČeštinaDanskDeutschEestiΕλληνικάEspañolفارسیFrançais한국어ItalianoBahasa MelayuNederlands日本語NorskОлык марийPolskiPortuguêsRomânăРусскийСрпски / srpskiSvenskaไทยTürkçeУкраїнська中文				
				Edit links			
		
				
		
				
						
								 This page was last edited on 28 March 2018, at 13:56.
								Text is available under the Creative Commons Attribution-ShareAlike License;
additional terms may apply.  By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.
							
						
								Privacy policy
								About Wikipedia
								Disclaimers
								Contact Wikipedia
								Developers
								Cookie statement
								Mobile view
							
										
										
											
										
											
									
						
		
		(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.148","walltime":"0.194","ppvisitednodes":{"value":724,"limit":1000000},"ppgeneratednodes":{"value":0,"limit":1500000},"postexpandincludesize":{"value":31708,"limit":2097152},"templateargumentsize":{"value":98,"limit":2097152},"expansiondepth":{"value":7,"limit":40},"expensivefunctioncount":{"value":0,"limit":500},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":13054,"limit":5000000},"entityaccesscount":{"value":0,"limit":400},"timingprofile":["100.00%  117.948      1 -total"," 77.43%   91.325      1 Template:Reflist"," 38.35%   45.231      4 Template:Cite_book"," 22.50%   26.533      1 Template:Data_types"," 20.07%   23.675      7 Template:Cite_web"," 19.88%   23.449      1 Template:Navbox","  1.44%    1.703      1 Template:Main_other","  1.08%    1.273      1 Template:Column-width"]},"scribunto":{"limitreport-timeusage":{"value":"0.060","limit":"10.000"},"limitreport-memusage":{"value":3372178,"limit":52428800}},"cachereport":{"origin":"mw1347","timestamp":"20180328135604","ttl":1900800,"transientcontent":false}}});});(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":87,"wgHostname":"mw1332"});});
	

