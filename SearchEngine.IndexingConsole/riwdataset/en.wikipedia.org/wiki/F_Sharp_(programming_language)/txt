



F Sharp (programming language) - Wikipedia
document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );
(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"F_Sharp_(programming_language)","wgTitle":"F Sharp (programming language)","wgCurRevisionId":830202240,"wgRevisionId":830202240,"wgArticleId":239964,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Wikipedia articles needing clarification from September 2015","All articles with unsourced statements","Articles with unsourced statements from September 2015","All articles with specifically marked weasel-worded phrases","Articles with specifically marked weasel-worded phrases from September 2015","Official website different in Wikidata and Wikipedia",".NET programming languages","Cross-platform free software","Functional languages","Microsoft free software","Microsoft Research","ML programming language family","OCaml programming language family","Pattern matching programming languages","Programming languages created in 2005","Software using the Apache license","Statically typed programming languages"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"F_Sharp_(programming_language)","wgRelevantArticleId":239964,"wgRequestId":"WsIkSQpAMF0AAJDqMCkAAABV","wgIsProbablyEditable":true,"wgRelevantPageIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgFlaggedRevsParams":{"tags":{}},"wgStableRevisionId":null,"wgWikiEditorEnabledModules":[],"wgBetaFeaturesFeatures":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgPopupsShouldSendModuleToUser":true,"wgPopupsConflictsWithNavPopupGadget":false,"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en","usePageImages":true,"usePageDescriptions":true},"wgPreferredVariant":"en","wgMFExpandAllSectionsUserOption":true,"wgMFEnableFontChanger":true,"wgMFDisplayWikibaseDescriptions":{"search":true,"nearby":true,"watchlist":true,"tagline":false},"wgRelatedArticles":null,"wgRelatedArticlesUseCirrusSearch":true,"wgRelatedArticlesOnlyUseCirrusSearch":false,"wgULSCurrentAutonym":"English","wgNoticeProject":"wikipedia","wgCentralNoticeCookiesToDelete":[],"wgCentralNoticeCategoriesUsingLegacy":["Fundraising","fundraising"],"wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}","wgWikibaseItemId":"Q648619","wgScoreNoteLanguages":{"arabic":"العربية","catalan":"català","deutsch":"Deutsch","english":"English","espanol":"español","italiano":"italiano","nederlands":"Nederlands","norsk":"norsk","portugues":"português","suomi":"suomi","svenska":"svenska","vlaams":"West-Vlams"},"wgScoreDefaultNoteLanguage":"nederlands","wgCentralAuthMobileDomain":false,"wgCodeMirrorEnabled":false,"wgVisualEditorToolbarScrollOffset":0,"wgVisualEditorUnsupportedEditParams":["undo","undoafter","veswitched"],"wgEditSubmitButtonLabelPublish":true});mw.loader.state({"ext.gadget.charinsert-styles":"ready","ext.globalCssJs.user.styles":"ready","ext.globalCssJs.site.styles":"ready","site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","ext.cite.styles":"ready","ext.pygments":"ready","wikibase.client.init":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.uls.interlanguage":"ready","ext.wikimediaBadges":"ready","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready","ext.globalCssJs.user":"ready","ext.globalCssJs.site":"ready"});mw.loader.implement("user.tokens@1dqfd7l",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["ext.cite.a11y","site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","ext.gadget.teahouse","ext.gadget.ReferenceTooltips","ext.gadget.watchlist-notice","ext.gadget.DRN-wizard","ext.gadget.charinsert","ext.gadget.refToolbar","ext.gadget.extra-toolbar-buttons","ext.gadget.switcher","ext.centralauth.centralautologin","mmv.head","mmv.bootstrap.autostart","ext.popups","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.eventLogging.subscriber","ext.wikimediaEvents","ext.navigationTiming","ext.uls.eventlogger","ext.uls.init","ext.uls.compactlinks","ext.uls.interface","ext.3d","ext.centralNotice.geoIP","ext.centralNotice.startUp","skins.vector.js"]);});























		
		
		
			
			

F Sharp (programming language)			
				From Wikipedia, the free encyclopedia				
								
					Jump to:					navigation, 					search
				
				The correct title of this article is F# (programming language). The substitution or omission of the # is due to technical restrictions.
Not to be confused with F (programming language) or F* (programming language).

F#


F# logomark



Paradigm
multi-paradigm: functional, imperative, object-oriented, metaprogramming, reflective, concurrent


Family
ML


Designed by
Don Syme, Microsoft Research


Developer
Microsoft, The F# Software Foundation


First appeared
2005; 13 years ago (2005), version 1.0





Stable release

4.1[1] / March 8, 2017; 12 months ago (2017-03-08)






Typing discipline
static, strong, inferred


OS
Cross-platform: .NET Framework, Mono, JavaScript


License
Apache


Filename extensions
.fs, .fsi, .fsx, .fsscript


Website
fsharp.org


Influenced by


C#, Erlang, Haskell,[2] ML, OCaml,[3][4] Python, Scala


Influenced


C#,[5] Elm, F*, LiveScript




 F Sharp Programming at Wikibooks




F# (pronounced F sharp) is a strongly typed, multi-paradigm programming language that encompasses functional, imperative, and object-oriented programming methods. F# is most often used as a cross-platform Common Language Infrastructure (CLI) language, but it can also generate JavaScript[6] and graphics processing unit (GPU) code.[7]
F# is developed by the F# Software Foundation,[8] Microsoft and open contributors. An open source, cross-platform compiler for F# is available from the F# Software Foundation.[9] F# is also a fully supported language in Visual Studio[10] and Xamarin Studio.[11] Other tools supporting F# development include Mono, MonoDevelop, SharpDevelop, MBrace and WebSharper.[12] Plug-ins supporting F# exist for many widely used editors, most notably the Ionide extension for Atom and Visual Studio Code, and integrations for other editors such as Vim, Emacs, and Sublime Text.
F# is member of the ML language family and originated as a .NET Framework implementation of a core of the programming language OCaml,[3][4] It has also been influenced by C#, Python, Haskell,[2] Scala, and Erlang.



Contents


1 History

1.1 Versions
1.2 Language evolution


2 Language overview

2.1 Functional programming
2.2 Imperative programming
2.3 Object programming
2.4 Asynchronous programming
2.5 Parallel programming
2.6 Units of measure
2.7 Metaprogramming
2.8 Information-rich programming
2.9 Agent programming


3 Development tools
4 Application areas

4.1 Web programming
4.2 Analytical programming
4.3 Scripting


5 Open-source community
6 Compatibility
7 Examples
8 See also
9 Notes
10 References
11 External links



History[edit]
Versions[edit]
In the course of its development, the language has gone through several versions:



Version
Language specification
Date
Platforms
Runtime
Development tools


F# 1.x

May 2005[13]
Windows
.NET 1.0 - 3.5
Visual Studio 2005, Emacs


F# 2.0
August 2010
April 2010[14]
Linux, macOS, Windows
.NET 2.0 - 4.0, Mono
Visual Studio 2010, Emacs


F# 3.0
November 2012
August 2012[15]
Linux, macOS, Windows;
JavaScript,[6] GPU[7]
.NET 2.0 - 4.5, Mono
Visual Studio 2012, Emacs
WebSharper


F# 3.1
November 2013
October 2013[16]
Linux, macOS, Windows;
JavaScript,[6] GPU[7]
.NET 2.0 - 4.5, Mono
Visual Studio 2013, Xamarin Studio
Emacs, MonoDevelop
SharpDevelop, WebSharper
CloudSharper


F# 4.0
January 2016
July 2015[17]


Visual Studio 2015


F# 4.1

March 2017[18]
Linux, macOS, Windows,
JavaScript,[6] GPU[7]

.NET 3.5 - 4.6.2, .NET Core, Mono
Visual Studio 2017, Visual Studio for Mac,
Ionide, Visual Studio Code, Atom, WebSharper, Rider




Language evolution[edit]
F# uses an open development and engineering process. The language evolution process is managed by Don Syme from Microsoft Research as the benevolent dictator for life (BDFL) for the language design, together with the F# Software Foundation. Earlier versions of the F# language were designed by Microsoft and Microsoft Research using a closed development process.
F# originates from Microsoft Research, Cambridge. The language was originally designed and implemented by Don Syme,[3] according to whom in the fsharp team, they say the F is for "Fun".[19] Andrew Kennedy contributed to the design of units of measure.[3] The Visual F# Tools for Visual Studio are developed by Microsoft.[3] The F# Software Foundation developed the F# open-source compiler and tools, incorporating the open-source compiler implementation provided by the Microsoft Visual F# Tools team.[8]


Summary of versions


F# 1.0
F# 2.0
F# 3.0[20]
F# 3.1[21]
F# 4.0[22]
F# 4.1[23]


Features
added


Functional programming
Discriminated unions
Records
Tuples
Pattern matching
Type abbreviations
Object programming
Structs
Signature files
Scripting files
Imperative programming
Modules (no functors)
Nested modules
.NET Interoperability




Active patterns
Units of measure
Sequence expressions
Asynchronous programming
Agent programming
Extension members
Named arguments
Optional arguments
Array slicing
Quotations
Native interoperability
Computation expressions




Type providers
LINQ query expressions
CLIMutable attribute
Triple-quoted strings
Auto-properties
Provided units-of-measure




Named union type fields
Extensions to array slicing
Type inference enhancements




Printf on unitized values
Extension property initializers
Non-null provided types
Primary constructors as functions
Static parameters for provided methods
Printf interpolation
Extended #if grammar
Support for 'fixed'
Tailcall attribute
Multiple interface instantiations
Optional type args
Params dictionaries




Struct tuples which inter-operate with C# tuples
Struct annotations for Records
Struct annotations for Single-case Discriminated Unions
Underscores in numeric literals
Caller info argument attributes
Result type and some basic Result functions
Mutually referential types and modules within the same file
Implicit "Module" syntax on modules with shared name as type
Byref returns, supporting consuming C# ref-returning methods
Error message improvements





Language overview[edit]
Functional programming[edit]
F# is a strongly typed functional-first language that uses type inference. The programmer does not need to declare types—the compiler deduces types during compilation (type inference). F# also allows explicit type annotations, and requires them in some situations.
F# is an expression-based language using eager evaluation. Every statement in F#, including if expressions, try expressions and loops, is a composable expression with a static type.[24] Functions and expressions that do not return any value have a return type of unit. F# uses the let keyword for binding values to a name.[24] For example:


let x = 3 + 4

binds the value 7 to the name x.
New types are defined using the type keyword. For functional programming, F# provides tuple, record, discriminated union, list, option, and result types.[24] A tuple represents a set of n values, where n ≥ 0. The value n is called the arity of the tuple. A 3-tuple would be represented as (A, B, C), where A, B, and C are values of possibly different types. A tuple can be used to store values only when the number of values is known at design-time and stays constant during execution.
A record is a type where the data members are named. Here is an example of record definition:


 type R = 
        { Name : string 
         Age : int }

Records can be created as let r = { Name="AB"; Age=42 }. The with keyword is used to create a copy of a record, as in { r with Name="CD" }, which creates a new record by copying r and changing the value of the Name field (assuming the record created in the last example was named r).
A discriminated union type is a type-safe version of C unions. For example,


 type A = 
    | UnionCaseX of string
    | UnionCaseY of int

Values of the union type can correspond to either union case. The types of the values carried by each union case is included in the definition of each case.
The list type is an immutable linked list represented either using a head::tail notation (:: is the cons operator) or a shorthand as [item1; item2; item3]. An empty list is written []. The option type is a discriminated union type with choices Some(x) or None. F# types may be generic, implemented as generic .NET types.
F# supports lambda functions and closures.[24] All functions in F# are first class values and are immutable.[24] Functions can be curried. Being first-class values, functions can be passed as arguments to other functions. Like other functional programming languages, F# allows function composition using the >> and << operators.
F# provides sequence expressions[25] that define a sequence seq { ... }, list [ ... ] or array [| ... |] through code that generates values. For example,


 seq { for b in 0 .. 25 do
           if b < 15 then
               yield b*b }

forms a sequence of squares of numbers from 0 to 14 by filtering out numbers from the range of numbers from 0 to 25. Sequences are generators – values are generated on-demand (i.e., are lazily evaluated) – while lists and arrays are evaluated eagerly.
F# uses pattern matching to bind values to names. Pattern matching is also used when accessing discriminated unions – the union is value matched against pattern rules and a rule is selected when a match succeeds. F# also supports Active Patterns as a form of extensible pattern matching.[26] It is used, for example, when multiple ways of matching on a type exist.[24]
F# supports a general syntax for defining compositional computations called computation expressions. Sequence expressions, asynchronous computations and queries are particular kinds of computation expressions. Computation expressions are an implementation of the monad pattern.[25]
Imperative programming[edit]
F# support for imperative programming includes

for loops
while loops
arrays, created with the [| ... |] syntax
hash table, created with the dict [ ... ] syntax or System.Collections.Generic.Dictionary<_,_> type.

Values and record fields can also be labelled as mutable. For example:


// Define 'x' with initial value '1'
let mutable x = 1
// Change the value of 'x' to '3'
x <- 3

Also, F# supports access to all CLI types and objects such as those defined in the System.Collections.Generic namespace defining imperative data structures.
Object programming[edit]
Like other Common Language Infrastructure (CLI) languages, F# can use CLI types and objects through object programming.[24] F# support for object programming in expressions includes:

Dot-notation, e.g., x.Name
Object expressions, e.g., { new obj() with member x.ToString() = "hello" }
Object construction, e.g., new Form()
Type tests, e.g., x :? string
Type coercions, e.g., x :?> string
Named arguments, e.g., x.Method(someArgument=1)
Named setters, e.g., new Form(Text="Hello")
Optional arguments, e.g., x.Method(OptionalArgument=1)

Support for object programming in patterns includes

Type tests, e.g., :? string as s
Active patterns, which can be defined over object types[26]

F# object type definitions can be class, struct, interface, enum, or delegate type definitions, corresponding to the definition forms found in C#. For example, here is a class with a constructor taking a name and age, and declaring two properties.


/// A simple object type definition
type Person(name : string, age : int) =
    member x.Name = name
    member x.Age = age

Asynchronous programming[edit]
F# supports asynchronous programming through asynchronous workflows.[27] An asynchronous workflow is defined as a sequence of commands inside an async{ ... }, as in


let asynctask = 
    async { let req = WebRequest.Create(url)
            let! response = req.GetResponseAsync()
            use stream = response.GetResponseStream()
            use streamreader = new System.IO.StreamReader(stream)
            return streamreader.ReadToEnd() }

The let! indicates that the expression on the right (getting the response) should be done asynchronously but the flow should only continue when the result is available. In other words, from the point of view of the code block, it's as if getting the response is a blocking call, whereas from the point of view of the system, the thread won't be blocked and may be used to process other flows while the result needed for this one doesn't become available.
The async block may be invoked using the Async.RunSynchronously function. Multiple async blocks can be executed in parallel using the Async.Parallel function that takes a list of async objects (in the example, asynctask is an async object) and creates another async object to run the tasks in the lists in parallel. The resultant object is invoked using Async.RunSynchronously.[27] Inversion of control in F# follows this pattern.[27]
Parallel programming[edit]
Parallel programming is supported partly through the Async.Parallel, Async.Start and other operations that run asynchronous blocks in parallel.
Parallel programming is also supported through the Array.Parallel functional programming operators in the F# standard library, direct use of the System.Threading.Tasks task programming model, the direct use of .NET thread pool and .NET threads and through dynamic translation of F# code to alternative parallel execution engines such as GPU[7] code.
Units of measure[edit]
The F# type system supports units of measure checking for numbers.[28] The units of measure feature integrates with F# type inference to require minimal type annotations in user code.[29]
Metaprogramming[edit]
F# allows some forms of syntax customizing via metaprogramming to support embedding custom domain-specific languages within the F# language, particularly through computation expressions.[24]
F# includes a feature for run-time meta-programming called quotations.[30] A quotation expression evaluates to an abstract syntax tree representation of the F# expressions. Similarly, definitions labelled with the [<ReflectedDefinition>] attribute can also be accessed in their quotation form. F# quotations are used for various purposes including to compile F# code into JavaScript[6] and GPU[7] code. (Quotations represent their F# code expressions as data for use by other parts of the program while requiring it to be syntactically correct F# code).
Information-rich programming[edit]
F# 3.0 introduced a form of compile-time meta-programming through statically extensible type generation called F# type providers.[31] F# type providers allow the F# compiler and tools to be extended with components that provide type information to the compiler on-demand at compile time. F# type providers have been used to give strongly typed access to connected information sources in a scalable way, including to the Freebase knowledge graph.[32]
In F# 3.0 the F# quotation and computation expression features are combined to implement LINQ queries.[33] For example:


// Use the OData type provider to create types that can be used to access the Northwind database.
open Microsoft.FSharp.Data.TypeProviders

type Northwind = ODataService<"http://services.odata.org/Northwind/Northwind.svc">
let db = Northwind.GetDataContext()

// A query expression.
let query1 = query { for customer in db.Customers do
                     select customer }

The combination of type providers, queries and strongly typed functional programming is known as information rich programming.[34]
Agent programming[edit]
F# supports a variation of the Actor programming model through the in-memory implementation of lightweight asynchronous agents. For example, the following code defines an agent and posts 2 messages:


let counter =
    MailboxProcessor.Start(fun inbox ->
        let rec loop n =
            async { do printfn "n = %d, waiting..." n
                    let! msg = inbox.Receive()
                    return! loop(n+msg) }
        loop 0)

Development tools[edit]

The Visual F# tools from Microsoft include full integrated development environment (IDE) integration in Visual Studio. With the language service installed, Visual Studio can be used to create F# projects and its debugger used on F# code. The Visual F# tools include a Visual Studio-hosted read–eval–print loop (REPL) interactive console that can execute F# code as it is written. Visual Studio for Mac also fully supports F# projects.
Visual Studio Code contains full support for F# via the Ionide extension.
F# can be developed with any text editor. Specific support exists in editors such as Emacs.
Fable, the F# |> Babel project, provides support for targeting JavaScript as a compilation backend for F# code.[35]
WebSharper[36] is a framework for cross-tier JavaScript and HTML5 development with F#.
MonoDevelop is an integrated development environment supporting F# programming on Linux, macOS, and Windows including support for the interactive console as used by Visual Studio.
SharpDevelop has supported F# since version 3.0.
MBrace is a framework and runtime for the development of applications with F# for the cloud.
LINQPad has supported F# since version 2.x.
Xamarin Studio supports F# since version 3.0.

Application areas[edit]
F# is a general-purpose programming language.
Web programming[edit]
F# is a central part of the WebSharper framework where F# code is executed as .NET code on a server and as JavaScript code on a client.[36]
Analytical programming[edit]
Among others, F# is used for quantitative finance programming,[37] energy trading and portfolio optimization,[38] machine learning,[39] business intelligence[40] and social gaming on Facebook.[41]
In the 2010s, F# has been positioned as an optimized alternative to C#. F#'s scripting ability and inter-language compatibility with all Microsoft products have made it popular among developers. Many developers are creating systems based on F# and use C# WCF Services.[clarification needed][citation needed][who?]
Scripting[edit]
F# can be used as a scripting language, mainly for desktop read–eval–print loop (REPL) scripting.[42]
Open-source community[edit]
The F# open-source community includes the F# Software Foundation[8] and the F# Open Source Group at GitHub.[9]
Compatibility[edit]
F# features a legacy "ML compatibility mode" that can directly compile programs written in a large subset of OCaml roughly, with no functors, objects, polymorphic variants, or other additions.
Examples[edit]
A few small samples follow:


// This is a comment for a sample hello world program.
open System
Console.WriteLine("Hello World!")

A Person class with a constructor taking a name and age and two immutable properties.


/// This is a documentation comment for a type definition.
type Person(name : string, age : int) =
    member x.Name = name
    member x.Age = age
    
/// class instantiation
let mrSmith = Person("Smith", 42)

A simple example that is often used to demonstrate the syntax of functional languages is the factorial function for non-negative 32-bit integers, here shown in F#:


/// Using pattern matching expression
let rec factorial n =
    match n with
    | 0 -> 1
    | _ -> n * factorial (n - 1)

/// For a single-argument functions there is syntactic sugar (pattern matching function):
let rec factorial = function 
    | 0 -> 1 
    | n -> n * factorial (n - 1)
    
/// Using fold and range operator
let factorial n = [1..n] |> Seq.fold (*) 1

Iteration examples:


/// Iteration using a 'for' loop
let printList lst = 
    for x in lst do
        printfn "%d" x

/// Iteration using a higher-order function
let printList2 lst = 
    List.iter (printfn "%d") lst

/// Iteration using a recursive function and pattern matching
let rec printList3 lst =
    match lst with
    | [] -> ()
    | h :: t ->
        printfn "%d" h
        printList3 t

Fibonacci examples:


/// Fibonacci Number formula
let rec fib n =
    match n with
    | 0 | 1 -> n
    | _ -> fib (n - 2) + fib (n - 1)

/// Another approach - a lazy infinite sequence of Fibonacci numbers
let fibSeq = Seq.unfold (fun (a,b) -> Some(a+b, (b, a+b))) (0,1)

// Print even fibs
[1 .. 10]
|> List.map     fib
|> List.filter  (fun n -> (n % 2) = 0)
|> printList

// Same thing, using a list expression
[ for i in 1..10 do
    let r = fib i
    if r % 2 = 0 then yield r ]
|> printList

A sample Windows Forms program:


// Open the Windows Forms library
open System.Windows.Forms

// Create a window and set a few properties
let form = new Form(Visible=true, TopMost=true, Text="Welcome to F#")

// Create a label to show some text in the form
let label =
    let x = 3 + (4 * 5)
    new Label(Text = sprintf "x = %d" x)

// Add the label to the form
form.Controls.Add(label)

// Finally, run the form
[<System.STAThread>]
Application.Run(form)

Asynchronous parallel programming sample (parallel CPU and I/O tasks):


/// A simple prime number detector
let isPrime (n:int) =
   let bound = int (sqrt (float n))
   seq {2 .. bound} |> Seq.forall (fun x -> n % x <> 0)

// We are using async workflows
let primeAsync n =
    async { return (n, isPrime n) }

/// Return primes between m and n using multiple threads
let primes m n =
    seq {m .. n}
        |> Seq.map primeAsync
        |> Async.Parallel
        |> Async.RunSynchronously
        |> Array.filter snd
        |> Array.map fst

// Run a test
primes 1000000 1002000
    |> Array.iter (printfn "%d")

See also[edit]


Free and open-source software portal



OCaml
C Sharp (programming language) (C#)
.NET Framework
Scala (programming language)
Clojure
Haskell (programming language)
Nemerle

Notes[edit]


^ "Announcing F# 4.1 and the Visual F# Tools for Visual Studio 2017". Microsoft. March 7, 2017. Retrieved May 25, 2017. 
^ a b Syme, Granicz & Cisternino (2007:2)
^ a b c d e "F# Historical Acknowledgements". Retrieved 2012-11-24. 
^ a b Syme, Don (2006). "Leveraging .NET Meta-programming Components from F#". [F#] is rooted in the Core ML design, and in particular has a core language largely compatible with that of OCaml 
^ for async
^ a b c d e The F# Software Foundation. "Using F# with HTML5 Web Applications". Retrieved 2014-06-07. 
^ a b c d e f The F# Software Foundation. "Using F# for GPU Programming". Retrieved 2014-06-07. 
^ a b c The F# Software Foundation. "The F# Software Foundation". Retrieved 2012-11-24. 
^ a b The F# Software Foundation. "F# Compiler (open source edition) @ github". Retrieved 2012-11-24. 
^ S. Somasegar. "F# - A functional Programming Language". Retrieved 2007-10-18. 
^ Friedman, Nat (May 28, 2014). "Announcing Xamarin 3". Retrieved August 26, 2014. 
^ Pickering, Robert (2009). Beginning F#, Apress. p. 11.
^ Syme, Don. "F# 1.0.8 released". Microsoft. Retrieved September 7, 2014. 
^ Syme, Don. "F# 2.0 released as part of Visual Studio 2010". Microsoft. Retrieved September 7, 2014. 
^ Zander, Jason. "Visual Studio 2012 and .NET Framework 4.5 released to the web". Microsoft. Retrieved September 7, 2014. 
^ "Visual Studio 2013 released to web". Microsoft. Retrieved September 7, 2014. 
^ "Announcing the RTM of Visual F# 4.0". Microsoft. Retrieved September 15, 2015. 
^ "Announcing F# 4.1 and the Visual F# Tools for Visual Studio 2017". Retrieved 2017-03-08. 
^ Edwards, Kathryn (23 December 2008). "The A-Z of programming languages: F#". networkworld.com. IDG. Retrieved 8 August 2016. 
^ McNamara, Brian. "More About F# 3.0 Language Features". Microsoft. Retrieved September 7, 2014. 
^ McNamara, Brian. "Announcing a pre-release of F# 3.1". Microsoft. Retrieved September 7, 2014. 
^ "Announcing the RTM of Visual F# 4.0". Retrieved 2017-03-08. 
^ "Announcing F# 4.1 and the Visual F# Tools for Visual Studio 2017". Retrieved 2017-03-08. 
^ a b c d e f g h "F# Language Overview" (PDF). Retrieved 2007-12-14. 
^ a b "Some Details on F# Computation Expressions". Retrieved 2007-12-14. 
^ a b "Pattern Matching in F# Part 2 : Active Patterns". Retrieved 2012-11-24. 
^ a b c "Introducing F# Asynchronous Workflows". Retrieved 2007-12-14. 
^ "Units of Measure (F#)". Retrieved 2012-11-24. 
^ "Units of Measure in F#: Part One, Introducing Units". Retrieved 2012-11-24. 
^ "Code Quotations (F#)". Retrieved 2012-11-24. 
^ "Type Providers". Retrieved 2012-11-24. 
^ "New Tech Report from Microsoft Research: Strongly-Typed Language Support for Internet-Scale Information Sources". Retrieved 2012-11-24. 
^ "Query Expressions (F#)". Retrieved 2012-11-24. 
^ "F# 3.0 – LINQ + Type Providers= Information Rich Programming". Retrieved 2012-11-24. 
^ "Fable: JavaScript you can be proud of!". fable.io. Retrieved 2017-12-09. 
^ a b Intellifactory. "WebSharper home". Retrieved 2012-11-24. 
^ "Microsoft Case Studies:Microsoft Visual Studio 2012 - Financial Services Firm". Retrieved 2012-11-25. 
^ "F# for Energy Trading and Portfolio Optimization". Retrieved 2012-11-25. 
^ "Microsoft Case Study: Grange Insurance". Retrieved 2012-11-25. 
^ "Learning with F#". Retrieved 2012-11-25. 
^ "F# Job in Facebook Social Gaming". Retrieved 2012-11-25. 
^ "Scripting in F#". Retrieved 2012-11-25. 


References[edit]

Syme, Don; Granicz, Adam; Cisternino, Antonio (2007). "Expert F#". Apress. 
Harrop, Jon (2010). "Visual F# 2010 for Technical Computing". Flying Frog Consultancy. 
Pickering, Robert (2007). "Foundations of F#". Apress. 
Smith, Chris (2009). "Programming F#". O'Reilly. 
Petricek, Tomas (2009). "Real World Functional Programming With Examples in F# and C#". Manning Publications. 
Hansen, Michael; Rischel, Hans (2013). "Functional Programming Using F#". Cambridge University Press. 
Astborg, Johan (2013). "F# for Quantitative Finance". Packt Publishing. 
Lundin, Mikael (2015). "Testing with F#". Packt Publishing. 

External links[edit]



Wikibooks has a book on the topic of: F Sharp Programming



Official website The F# Software Foundation
The F# Open Source Group at GitHub
The Visual F# Developer Center
Tsunami, an embeddable desktop F# IDE
Cloud Tsunami, an embeddable Silverlight F# IDE
Try F#, for learning F# in a web browser
F# Snippets Site
The Visual F# team blog
The original Microsoft Research website for F#
Planet F#
The F# Survival Guide, Dec 2009 (Web-based book)
The F# Language Specification
An introduction to F# programming
A tutorial showing the process of reaching a functional design; includes test and parallel coding







v
t
e


.NET Framework






Version history
.NET strategy





Architecture



Common Language Runtime (CLR)
COM Interop
Framework Class Library (FCL)





Components



ADO.NET

Entity Framework


ASP.NET

AJAX
Core
Dynamic Data
MVC
Razor


ClickOnce
Dynamic Language Runtime
Extensible Application Markup Language (XAML)
Language Integrated Query (LINQ)
Managed Extensibility Framework
Microsoft Silverlight
Microsoft XNA
Parallel Extensions
Windows Communication Foundation (WCF)

WCF Data Services


Windows Forms (WinForms)
Windows Identity Foundation (WIF)
Windows Presentation Foundation (WPF)
Windows Workflow Foundation (WF)
.NET Remoting





Tools




Decompilers



.NET Reflector
dotPeek





Obfuscators



Dotfuscator
SmartAssembly
CodeArmor
Turbo





Misc



CLR Profiler
ILAsm
.NET Compiler Platform
Native Image Generator (NGen)
XAMLPad








IDEs



Visual Studio

Blend
Express


MonoDevelop
SharpDevelop
Xamarin Studio





Organizations



.NET Foundation
Microsoft
Xamarin








 Category
 List












v
t
e


Common Language Infrastructure



Architecture



Application domain
Code Access Security
Common Intermediate Language (CIL)

CIL instructions


Common Type System (CTS)
Platform Invocation Services (P/Invoke)
Virtual Execution System (VES)





Components



Assembly
Delegate
Global Assembly Cache (GAC)
Manifest
Metadata





Standard
Libraries




Kernel Profile



Base Class Library (BCL)
Runtime Infrastructure Library





Compact Profile



Network Library
Reflection Library
XML Library








Extended Array Library
Extended Numerics Library
Parallel Library
Vararg Library








Implementations




Microsoft



.NET Framework
.NET Compact Framework
.NET Micro Framework
Shared Source Common Language Infrastructure





Other



.NET Core
Mono
Portable.NET








Languages




Microsoft



C#
Visual Basic .NET
C++/CLI

Managed


F#
Q#
J#
JScript .NET
PowerShell





Other



Axum
A#
Boo
Cobra
IronScheme

IronLisp


IronPython
IronRuby
Nemerle
Oxygene
Phalanger
P#
Scala





Comparison



C# and Java
C# and Visual Basic .NET
Java and .NET platforms
Visual Basic and Visual Basic .NET








Organizations



.NET Foundation
DotGNU
Microsoft
Xamarin












					
						Retrieved from "https://en.wikipedia.org/w/index.php?title=F_Sharp_(programming_language)&oldid=830202240"					
				Categories: .NET programming languagesCross-platform free softwareFunctional languagesMicrosoft free softwareMicrosoft ResearchML programming language familyOCaml programming language familyPattern matching programming languagesProgramming languages created in 2005Software using the Apache licenseStatically typed programming languagesHidden categories: Wikipedia articles needing clarification from September 2015All articles with unsourced statementsArticles with unsourced statements from September 2015All articles with specifically marked weasel-worded phrasesArticles with specifically marked weasel-worded phrases from September 2015Official website different in Wikidata and Wikipedia				
							
		
		
			Navigation menu
			
									
						Personal tools
						
							Not logged inTalkContributionsCreate accountLog in						
					
									
										
						Namespaces
						
							ArticleTalk						
					
										
												
						
							Variants
						
						
							
															
						
					
									
				
										
						Views
						
							ReadEditView history						
					
										
						
						More
						
							
															
						
					
										
						
							Search
						
						
							
															
						
					
									
			
			
				
						
			Navigation
			
								
					Main pageContentsFeatured contentCurrent eventsRandom articleDonate to WikipediaWikipedia store				
							
		
			
			Interaction
			
								
					HelpAbout WikipediaCommunity portalRecent changesContact page				
							
		
			
			Tools
			
								
					What links hereRelated changesUpload fileSpecial pagesPermanent linkPage informationWikidata itemCite this page				
							
		
			
			Print/export
			
								
					Create a bookDownload as PDFPrintable version				
							
		
			
			Languages
			
								
					العربيةCatalàČeštinaDanskDeutschEspañolفارسیFrançais한국어ItalianoქართულიMagyarBahasa MelayuNederlands日本語NorskPolskiPortuguêsРусскийSlovenčinaСрпски / srpskiSvenskaไทยTürkçeУкраїнська中文				
				Edit links			
		
				
		
				
						
								 This page was last edited on 13 March 2018, at 11:30.
								Text is available under the Creative Commons Attribution-ShareAlike License;
additional terms may apply.  By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.
							
						
								Privacy policy
								About Wikipedia
								Disclaimers
								Contact Wikipedia
								Developers
								Cookie statement
								Mobile view
							
										
										
											
										
											
									
						
		
		(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.616","walltime":"0.718","ppvisitednodes":{"value":4057,"limit":1000000},"ppgeneratednodes":{"value":0,"limit":1500000},"postexpandincludesize":{"value":137332,"limit":2097152},"templateargumentsize":{"value":6021,"limit":2097152},"expansiondepth":{"value":25,"limit":40},"expensivefunctioncount":{"value":5,"limit":500},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":69067,"limit":5000000},"entityaccesscount":{"value":1,"limit":400},"timingprofile":["100.00%  597.244      1 -total"," 36.05%  215.307      1 Template:Reflist"," 25.11%  149.940     35 Template:Cite_web"," 19.25%  114.998      2 Template:Infobox"," 15.47%   92.377      1 Template:Infobox_programming_language","  7.36%   43.939      6 Template:Navbox","  6.71%   40.098      9 Template:Cite_journal","  6.70%   40.005      1 Template:Clarify","  5.97%   35.684      1 Template:Fix-span","  5.80%   34.667      1 Template:Infobox_software/simple"]},"scribunto":{"limitreport-timeusage":{"value":"0.293","limit":"10.000"},"limitreport-memusage":{"value":6322319,"limit":52428800}},"cachereport":{"origin":"mw1310","timestamp":"20180402011727","ttl":86400,"transientcontent":true}}});});(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":72,"wgHostname":"mw1258"});});
	

