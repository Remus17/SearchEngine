



View source for Python (programming language) - Wikipedia
document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );
(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Python_(programming_language)","wgTitle":"Python (programming language)","wgCurRevisionId":833660930,"wgRevisionId":0,"wgArticleId":23862,"wgIsArticle":false,"wgIsRedirect":false,"wgAction":"edit","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":true,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Python_(programming_language)","wgRelevantArticleId":23862,"wgRequestId":"WsJJrgpAAD8AAJudfdEAAAAS","wgIsProbablyEditable":true,"wgRelevantPageIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgFlaggedRevsParams":{"tags":{}},"wgStableRevisionId":null,"wgWikiEditorEnabledModules":[],"wgBetaFeaturesFeatures":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgPopupsShouldSendModuleToUser":true,"wgPopupsConflictsWithNavPopupGadget":false,"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en","usePageImages":true,"usePageDescriptions":true},"wgPreferredVariant":"en","wgMFExpandAllSectionsUserOption":true,"wgMFEnableFontChanger":true,"wgMFDisplayWikibaseDescriptions":{"search":true,"nearby":true,"watchlist":true,"tagline":false},"wgRelatedArticles":null,"wgRelatedArticlesUseCirrusSearch":true,"wgRelatedArticlesOnlyUseCirrusSearch":false,"wgULSCurrentAutonym":"English","wgNoticeProject":"wikipedia","wgCentralNoticeCookiesToDelete":[],"wgCentralNoticeCategoriesUsingLegacy":["Fundraising","fundraising"],"wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}","wgScoreNoteLanguages":{"arabic":"العربية","catalan":"català","deutsch":"Deutsch","english":"English","espanol":"español","italiano":"italiano","nederlands":"Nederlands","norsk":"norsk","portugues":"português","suomi":"suomi","svenska":"svenska","vlaams":"West-Vlams"},"wgScoreDefaultNoteLanguage":"nederlands","wgCentralAuthMobileDomain":false,"wgCodeMirrorEnabled":false,"wgVisualEditorToolbarScrollOffset":0,"wgVisualEditorUnsupportedEditParams":["undo","undoafter","veswitched"],"wgEditSubmitButtonLabelPublish":true});mw.loader.state({"ext.gadget.charinsert-styles":"ready","ext.globalCssJs.user.styles":"ready","ext.globalCssJs.site.styles":"ready","site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","ext.charinsert.styles":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.uls.interlanguage":"ready","ext.wikimediaBadges":"ready","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready","ext.globalCssJs.user":"ready","ext.globalCssJs.site":"ready"});mw.loader.implement("user.tokens@1dqfd7l",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["mediawiki.action.edit.collapsibleFooter","site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","ext.charinsert","ext.gadget.teahouse","ext.gadget.ReferenceTooltips","ext.gadget.watchlist-notice","ext.gadget.DRN-wizard","ext.gadget.charinsert","ext.gadget.refToolbar","ext.gadget.extra-toolbar-buttons","ext.gadget.switcher","ext.centralauth.centralautologin","mmv.head","mmv.bootstrap.autostart","ext.popups","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.eventLogging.subscriber","ext.wikimediaEvents","ext.navigationTiming","ext.uls.eventlogger","ext.uls.init","ext.uls.compactlinks","ext.uls.interface","ext.3d","ext.centralNotice.geoIP","skins.vector.js"]);});






















		
		
		
			
			

View source for Python (programming language)			
								← Python (programming language)
								
					Jump to:					navigation, 					search
				
				You do not have permission to edit this page, for the following reasons:


Your IP address is in a range which has been blocked on all wikis.

The block was made by Vituzzu (meta.wikimedia.org).
The reason given is hosting service with open proxies such as 67.207.94.79 .

Start of block: 13:14, 23 October 2017
Expiration of block: 13:14, 23 October 2022

You can contact Vituzzu to discuss the block.
You cannot use the "Email this user" feature unless a valid email address is specified in your account preferences and you have not been blocked from using it.
Your current IP address is 67.207.88.228, and the blocked range is 67.207.64.0/19.
Please include all above details in any queries you make.


You are currently unable to edit Wikipedia.
You are still able to view pages, but you are not currently able to edit, move, or create them.




Editing from 67.207.64.0/19 has been blocked (disabled) by KrakatoaKatie for the following reason(s):




The IP address that you are currently using has been blocked  because it is believed to be a web host provider. To prevent abuse, web hosts may be blocked from editing Wikipedia.


You will not be able to edit Wikipedia using a web host provider.
Since the web host acts like a proxy, because it hides your IP address, it has been blocked. To prevent abuse, these IPs may be blocked from editing Wikipedia. If you do not have any other way to edit Wikipedia, you will need to request an IP block exemption.
If you do not believe you are using a web host, you may appeal this block by adding the following text on your talk page: {{unblock|reason=Caught by a web host block but this host or IP is not a web host. Place any further information here. ~~~~}}. If you are using a Wikipedia account you will need to request an IP block exemption by either using the unblock template or by submitting an appealing using the unblock ticket request system. If you wish to keep your IP address private you can email the functionaries team.
Administrators: The IP block exemption user right should only be applied to allow users to edit using web host in exceptional circumstances, and they should usually be directed to the functionaries team via email. If you intend to give the IPBE user right, a CheckUser needs to take a look at the account. This can be requested most easily at SPI Quick Checkuser Requests. Unblocking an IP or IP range with this template is highly discouraged without at least contacting the blocking administrator.

: 
This block has been set to expire: 12:56, 12 August 2020.
Even if blocked, you will usually still be able to edit your user talk page and email other editors and administrators.





Other useful links: Blocking policy · Username policy ·  
Appealing blocks: policy and guide

If the block notice is unclear, or it does not appear to relate to your actions, please ask for assistance as described at Help:I have been blocked.



You can view and copy the source of this page:
== Syntax and semantics ==
{{Main article|Python syntax and semantics}}

Python is meant to be an easily readable language. Its formatting is visually uncluttered, and it often uses English keywords where other languages use punctuation. Unlike many other languages, it does not use [[curly bracket programming language|curly brackets]] to delimit blocks, and semicolons after statements are optional. It has fewer syntactic exceptions and special cases than [[C (programming language)|C]] or [[Pascal (programming language)|Pascal]].<ref name="AutoNT-52" />

=== Indentation ===
{{Main article|Python syntax and semantics#Indentation}}

Python uses [[whitespace character|whitespace]] indentation, rather than [[curly bracket programming language|curly brackets]] or keywords, to delimit [[block (programming)|blocks]]. An increase in indentation comes after certain statements; a decrease in indentation signifies the end of the current block.<ref name="AutoNT-53" /> Thus, the program's visual structure accurately represents the program's semantic structure.<ref name=guttag>{{Cite book| publisher = MIT Press| isbn = 978-0-262-52962-4| last = Guttag| first = John V.| title = Introduction to Computation and Programming Using Python: With Application to Understanding Data| date = 2016-08-12}}</ref> This feature is also sometimes termed the [[off-side rule]].

=== Statements and control flow ===
Python's [[Statement (computer science)|statements]] include (among others):

* The assignment statement (token '=', the equals sign). This operates differently than in traditional [[imperative programming]] languages, and this fundamental mechanism (including the nature of Python's version of ''variables'') illuminates many other features of the language. Assignment in [[C (programming language)|C]], e.g., <code>x = 2</code>, translates to "typed variable name x receives a copy of numeric value 2". The (right-hand) value is copied into an [[Memory allocation|allocated storage location]] for which the (left-hand) [[Variable (computer science)|variable name]] is the symbolic address. The memory allocated to the variable is large enough (potentially quite large) for the declared [[Type system|type]]. In the simplest case of Python assignment, using the same example, <code>x = 2</code>, translates to "(generic) name x receives a [[Pointer (computer programming)|reference]] to a separate, dynamically allocated [[Object (computer science)|object]] of numeric (int) type of value 2." This is termed ''binding'' the name to the object. Since the name's storage location doesn't ''contain'' the indicated value, it is improper to call it a ''variable''. Names may be subsequently rebound at any time to objects of greatly varying types, including strings, procedures, complex objects with data and methods, etc. Successive assignments of a common value to multiple names, e.g., <code>x = 2</code>; <code>y = 2</code>; <code>z = 2</code> result in allocating storage to (at most) three names and one numeric object, to which all three names are bound. Since a name is a generic reference holder it is unreasonable to associate a fixed [[Type system|data type]] with it. However at a given time a name will be bound to ''some'' object, which '''will''' have a type; thus there is [[Dynamic type|dynamic typing]].
* The <code>[[if-then-else|if]]</code> statement, which conditionally executes a block of code, along with <code>else</code> and <code>elif</code> (a contraction of else-if).
* The <code>[[Foreach#Python|for]]</code> statement, which iterates over an iterable object, capturing each element to a local variable for use by the attached block.
* The <code>[[While loop#Python|while]]</code> statement, which executes a block of code as long as its condition is true.
* The <code>[[Exception handling syntax#Python|try]]</code> statement, which allows exceptions raised in its attached code block to be caught and handled by <code>except</code> clauses; it also ensures that clean-up code in a <code>finally</code> block will always be run regardless of how the block exits.
* The <code>class</code> statement, which executes a block of code and attaches its local namespace to a [[class (computer science)|class]], for use in [[object-oriented programming]].
* The <code>def</code> statement, which defines a [[function (computing)|function]] or [[method (computing)|method]].
* The <code>with</code> statement, from Python 2.5 released on September 2006,<ref>https://www.python.org/download/releases/2.5/</ref> which encloses a code block within a context manager (for example, acquiring a [[lock (computer science)|lock]] before the block of code is run and releasing the lock afterwards, or opening a [[Computer file|file]] and then closing it), allowing [[Resource Acquisition Is Initialization]] (RAII)-like behavior and replaces a common try/finally idiom.<ref>https://www.python.org/download/releases/2.5/highlights/</ref>
* The <code>pass</code> statement, which serves as a [[NOP]]. It is syntactically needed to create an empty code block.
* The <code>[[assertion (programming)|assert]]</code> statement, used during debugging to check for conditions that ought to apply.
* The <code>yield</code> statement, which returns a value from a [[generator (computer science)#Python|generator]] function. From Python 2.5, <code>yield</code> is also an operator. This form is used to implement [[coroutine]]s.
* The <code>import</code> statement, which is used to import modules whose functions or variables can be used in the current program. There are four ways of using import: <code>import <module name></code> or <code>from <module name> import *</code> or <code>import numpy as np</code> or <code>from numpy import pi as Pie</code>.
* The <code>print</code> statement was changed to the <code>print()</code> function in Python 3.<ref name="diff_py2-3">{{cite book |last=Sweigart |first=Al|year=2010|chapter=Appendix A: Differences Between Python 2 and 3 |title=Invent Your Own Computer Games with Python |url=http://inventwithpython.com/appendixa.html|edition=2|isbn=978-0-9821060-1-3 |accessdate=20 February 2014}}</ref>

Python does not support [[tail call]] optimization or [[first-class continuations]], and, according to Guido van Rossum, it never will.<ref name="AutoNT-55" /><ref name="AutoNT-56" /> However, better support for [[coroutine]]-like functionality is provided in 2.5, by extending Python's [[generator (computer science)|generators]].<ref name="AutoNT-57" /> Before 2.5, generators were [[lazy evaluation|lazy]] [[iterator]]s; information was passed unidirectionally out of the generator. From Python 2.5, it is possible to pass information back into a generator function, and from Python 3.3, the information can be passed through multiple stack levels.<ref name="AutoNT-58" />

=== Expressions ===
Some Python [[Expression (computer science)|expressions]] are similar to languages such as [[C (programming language)|C]] and [[Java (programming language)|Java]], while some are not:

* Addition, subtraction, and multiplication are the same, but the behavior of division differs. There are two types of divisions in Python. They are floor division and integer division.<ref>{{cite web|title=division|url=https://docs.python.org|website=python.org}}</ref> Python also added the <code>**</code> operator for exponentiation.
* From Python 3.5, the new <code>@</code> infix operator was introduced. It is intended to be used by libraries such as NumPy for [[matrix multiplication]].<ref name=PEP465>{{cite web |title=PEP 0465 -- A dedicated infix operator for matrix multiplication |url=https://www.python.org/dev/peps/pep-0465/|website=python.org |accessdate=1 January 2016}}</ref><ref name=Python3.5Changelog>{{cite web |title=Python 3.5.1 Release and Changelog |url=https://www.python.org/downloads/release/python-351/|website=python.org |accessdate=1 January 2016}}</ref>
* In Python, <code>==</code> compares by value, versus Java, which compares numerics by value<ref>{{cite web |url=http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.21.1 |title=Chapter 15. Expressions - 15.21.1. Numerical Equality Operators == and != |publisher=[[Oracle Corporation]] |accessdate=28 August 2016}}</ref> and objects by reference.<ref>{{cite web |url=http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.21.3 |title=Chapter 15. Expressions - 15.21.3. Reference Equality Operators == and != |publisher=Oracle Corporation |accessdate=28 August 2016}}</ref> (Value comparisons in Java on objects can be performed with the <code>equals()</code> method.) Python's <code>is</code> operator may be used to compare object identities (comparison by reference). In Python, comparisons may be chained, for example <code>a <= b <= c</code>. 
* Python uses the words <code>and</code>, <code>or</code>, <code>not</code> for its boolean operators rather than the symbolic <code>&&</code>, <code>||</code>, <code>!</code> used in Java and C.
* Python has a type of expression termed a ''[[list comprehension#Python|list comprehension]]''. Python 2.4 extended list comprehensions into a more general expression termed a ''[[generator (computer science)|generator]] expression''.<ref name="AutoNT-59" />
* [[Anonymous function]]s are implemented using [[Lambda (programming)|lambda expressions]]; however, these are limited in that the body can only be one expression.
* Conditional expressions in Python are written as <code>x if c else y</code><ref name="AutoNT-60" /> (different in order of operands from the <code>[[?:|c ? x : y]]</code> operator common to many other languages).
* Python makes a distinction between [[list (computer science)|lists]] and [[tuple]]s. Lists are written as <code>[1, 2, 3]</code>, are mutable, and cannot be used as the keys of dictionaries (dictionary keys must be [[immutable]] in Python). Tuples are written as <code>(1, 2, 3)</code>, are immutable and thus can be used as the keys of dictionaries, provided all elements of the tuple are immutable. The <code>+</code> operator can be used to concatenate two tuples, which does not directly modify their contents, but rather produces a new tuple containing the elements of both provided tuples. Thus, given the variable <code>t</code> initially equal to <code>(1, 2, 3)</code>, executing <code>t = t + (4, 5)</code> first evaluates <code>t + (4, 5)</code>, which yields <code>(1, 2, 3, 4, 5)</code>, which is then assigned back to <code>t</code>, thereby effectively "modifying the contents" of <code>t</code>, while conforming to the immutable nature of tuple objects. Parentheses are optional for tuples in unambiguous contexts.<ref>{{cite web|title=4. Built-in Types &#8212; Python 3.6.3rc1 documentation|url=https://docs.python.org/3/library/stdtypes.html#tuple|website=python.org|accessdate=1 October 2017}}</ref> 
* Python features ''sequence unpacking'' where multiple expressions, each evaluating to anything that can be assigned to (a variable, a writable property, etc.), are associated in the identical manner to that forming tuple literals and, as a whole, are put on the left hand side of the equal sign in an assignment statement. The statement expects an ''iterable'' object on the right hand side of the equal sign that produces the same number of values as the provided writable expressions when iterated through, and will iterate through it, assigning each of the produced values to the corresponding expression on the left.{{citation needed|date=October 2017}} 
* Python has a "string format" operator <code>%</code>. This functions analogous to <code>[[printf]]</code> format strings in [[C (programming language)|C]], e.g. <code>"spam=%s eggs=%d" % ("blah", 2)</code> evaluates to <code>"spam=blah eggs=2"</code>. In Python 3 and 2.6+, this was supplemented by the <code>format()</code> method of the <code>str</code> class, e.g. <code>"spam={0} eggs={1}".format("blah", 2)</code>. Python 3.6 added "f-strings": <code>blah = "blah"; eggs = 2; f'spam={blah} eggs={eggs}'</code>.<ref name="pep-0498">{{cite web |title=PEP 498 -- Literal String Interpolation |url=https://www.python.org/dev/peps/pep-0498/|website=python.org |accessdate=8 March 2017}}</ref>
* Python has various kinds of [[string literal]]s:
** Strings delimited by single or double quote marks. Unlike in [[Unix shell]]s, [[Perl]] and Perl-influenced languages, single quote marks and double quote marks function identically. Both kinds of string use the backslash (<code>\</code>) as an [[escape character]]. [[String interpolation]] became available in Python 3.6 as "formatted string literals".<ref name="pep-0498"/>
** Triple-quoted strings, which begin and end with a series of three single or double quote marks. They may span multiple lines and function like [[here document]]s in shells, Perl and [[Ruby (programming language)|Ruby]].
** [[Raw string]] varieties, denoted by prefixing the string literal with an <code>r</code>. Escape sequences are not interpreted; hence raw strings are useful where literal backslashes are common, such as [[regular expression]]s and [[Microsoft Windows|Windows]]-style paths. Compare "<code>@</code>-quoting" in [[C Sharp (programming language)|C#]].
* Python has [[array index]] and [[array slicing]] expressions on lists, denoted as <code>a[key]</code>, <code>a[start:stop]</code> or <code>a[start:stop:step]</code>. Indexes are [[zero-based]], and negative indexes are relative to the end. Slices take elements from the ''start'' index up to, but not including, the ''stop'' index. The third slice parameter, called ''step'' or ''stride'', allows elements to be skipped and reversed. Slice indexes may be omitted, for example <code>a[:]</code> returns a copy of the entire list. Each element of a slice is a [[shallow copy]].

In Python, a distinction between expressions and statements is rigidly enforced, in contrast to languages such as [[Common Lisp]], [[Scheme (programming language)|Scheme]], or [[Ruby (programming language)|Ruby]]. This leads to duplicating some functionality. For example:

* [[List comprehensions]] vs. <code>for</code>-loops
* [[Conditional (programming)|Conditional]] expressions vs. <code>if</code> blocks
* The <code>eval()</code> vs. <code>exec()</code> built-in functions (in Python 2, <code>exec</code> is a statement); the former is for expressions, the latter is for statements.

Statements cannot be a part of an expression, so list and other comprehensions or [[Lambda (programming)|lambda expressions]], all being expressions, cannot contain statements. A particular case of this is that an assignment statement such as <code>a = 1</code> cannot form part of the conditional expression of a conditional statement. This has the advantage of avoiding a classic C error of mistaking an assignment operator <code>=</code> for an equality operator <code>==</code> in conditions: <code>if (c = 1) { ... }</code> is syntactically valid (but probably unintended) C code but <code>if c = 1: ...</code> causes a syntax error in Python.

=== Methods ===
[[Method (programming)|Methods]] on objects are [[function (programming)|functions]] attached to the object's class; the syntax <code>instance.method(argument)</code> is, for normal methods and functions, [[syntactic sugar]] for <code>Class.method(instance, argument)</code>. Python methods have an explicit <code>[[this (computer programming)|self]]</code> parameter to access [[instance data]], in contrast to the implicit <code>self</code> (or <code>this</code>) in some other object-oriented programming languages (e.g., [[C++]], [[Java (programming language)|Java]], [[Objective-C]], or [[Ruby (programming language)|Ruby]]).<ref name="AutoNT-61" />

=== Typing ===
Python uses [[duck typing]] and has typed objects but untyped variable names. Type constraints are not checked at [[compile time]]; rather, operations on an object may fail, signifying that the given object is not of a suitable type. Despite being [[Type system#Dynamic type checking and runtime type information|dynamically typed]], Python is [[strongly typed programming language|strongly typed]], forbidding operations that are not well-defined (for example, adding a number to a string) rather than silently attempting to make sense of them.

Python allows programmers to define their own types using [[class (computer science)|classes]], which are most often used for [[object-oriented programming]]. New [[object (computer science)|instances]] of classes are constructed by calling the class (for example, <code>SpamClass()</code> or <code>EggsClass()</code>), and the classes are instances of the [[metaclass]] <code>type</code> (itself an instance of itself), allowing [[metaprogramming]] and [[reflection (computer science)|reflection]].

Before version 3.0, Python had two kinds of classes: ''old-style'' and ''new-style''.<ref name="classy" /> The syntax of both styles is the same, the difference being whether the class <code>object</code> is inherited from, directly or indirectly (all new-style classes inherit from <code>object</code> and are instances of <code>type</code>). In versions of Python 2 from Python 2.2 onwards, both kinds of classes can be used. Old-style classes were eliminated in Python 3.0.

The long term plan is to support [[gradual typing]]<ref>{{cite web |url=https://lwn.net/Articles/627418/ |title=Type hinting for Python |publisher=LWN.net |date=24 December 2014 |accessdate=5 May 2015}}</ref> and from Python 3.5, the syntax of the language allows specifying static types but they are not checked in the default implementation, CPython. An experimental optional static type checker named ''mypy'' supports compile-time type checking.<ref>{{cite web |url=http://mypy-lang.org/ |title=mypy - Optional Static Typing for Python |publisher= |accessdate=28 January 2017}}</ref>

{|class="wikitable"
|+Summary of Python 3's built-in types
|-
! Type
! mutable
! Description
! Syntax example
|-
| <code>bool</code>
| immutable
| [[Boolean value]]
| <code>True</code><br><code>False</code>
|-
| <code>bytearray</code>
| mutable
| Sequence of [[byte]]s
| <code>bytearray(b'Some ASCII')</code><br><code>bytearray(b"Some ASCII")</code><br><code>bytearray([119, 105, 107, 105])</code>
|-
| <code>bytes</code>
| immutable
| Sequence of bytes
| <code>b'Some ASCII'</code><br><code>b"Some ASCII"</code><br><code>bytes([119, 105, 107, 105])</code>
|-
| <code>complex</code>
| immutable
| [[Complex number]] with real and imaginary parts
| <code>3+2.7j</code>
|-
| <code>dict</code>
| mutable
| [[Associative array]] (or dictionary) of key and value pairs; can contain mixed types (keys and values), keys must be a hashable type
| <code>{'key1': 1.0, 3: False}</code>
|-
| <code>ellipsis</code>
| 
| An [[Ellipsis (programming operator)|ellipsis]] placeholder to be used as an index in [[NumPy]] arrays
| <code>...</code>
|-
| <code>float</code>
| immutable
| [[Floating point]] number, system-defined precision
| <code>3.1415927</code>
|-
| <code>frozenset</code>
| immutable
| Unordered [[set (computer science)|set]], contains no duplicates; can contain mixed types, if hashable
| <code>frozenset([4.0, 'string', True])</code>
|-
| <code>int</code>
| immutable
| [[integer (computer science)|Integer]] of unlimited magnitude<ref name="pep0237" />
| <code>42</code>
|-
| <code>list</code>
| mutable
| [[list (computer science)|List]], can contain mixed types
| <code>[4.0, 'string', True]</code>
|-
| <code>set</code>
| mutable
| Unordered [[set (computer science)|set]], contains no duplicates; can contain mixed types, if hashable
| <code>{4.0, 'string', True}</code>
|-
| <code>str</code>
| [[immutable object|immutable]]
| A [[character string]]: sequence of Unicode codepoints
| <code>'Wikipedia'</code><br><code>"Wikipedia"</code><br><code>"""Spanning<br>multiple<br>lines"""</code>
|-
| <code>tuple</code>
| immutable
| Can contain mixed types
| <code>(4.0, 'string', True)</code>But we can append elements using __add__ .

a = (4.0, 'string' , True).__add__(('hi' ,))

now a gives <code>(4.0, 'string', True ,'hi')</code>
|}

=== Mathematics ===
Python has the usual C arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>). It also has <code>**</code> for exponentiation, e.g. <code>5**3 == 125</code> and <code>9**0.5 == 3.0</code>, and a new matrix multiply <code>@</code> operator is included in version 3.5.<ref>{{cite web |url=http://legacy.python.org/dev/peps/pep-0465/ |title=PEP 465 -- A dedicated infix operator for matrix multiplication |work=python.org}}</ref> Additionally, it has a unary operator (<code>~</code>), which essentially inverts all the bits of its one argument. For integers, this means <code>~x=-x-1</code>.<ref>{{cite web |url=https://stackoverflow.com/questions/8305199/the-tilde-operator-in-python |title=The tilde operator in Python - Stackoverflow |work=stackoverflow.com}}</ref> Other operators include bitwise shift operators <code>x << y</code>, which shifts <code>x</code> to the left <code>y</code> places, the same as <code>x*(2**y) </code>, and <code>x >> y</code>, which shifts <code>x</code> to the right <code>y</code> places, the same as <code>x/(2**y) </code>.<ref>{{cite web |url=https://wiki.python.org/moin/BitwiseOperators |title=BitwiseOperators - Python Wiki |work=wiki.python.org}}</ref>

The behavior of division has changed significantly over time:<ref name="pep0238"/>

* Python 2.1 and earlier use the C division behavior. The <code>/</code> operator is integer division if both operands are integers, and floating-point division otherwise. Integer division rounds towards 0, e.g. {{nowrap|1=<code>7/3 == 2</code>}} and {{nowrap|1=<code>-7/3 == -2</code>.}}
* Python 2.2 changes integer division to round towards negative infinity, e.g. <code>7/3 == 2</code> and <code>-7/3 == -3</code>. The floor division <code>//</code> operator is introduced. So <code>7//3 == 2</code>, <code>-7//3 == -3</code>, <code>7.5//3 == 2.0</code> and <code>-7.5//3 == -3.0</code>. Adding <code>from __future__ import division</code> causes a module to use Python 3.0 rules for division (see next).
* Python 3.0 changes <code>/</code> to be always floating-point division. In Python terms, the pre-3.0 <code>/</code> is ''classic division'', the version-3.0 <code>/</code> is ''real division'', and <code>//</code> is ''floor division''.

Rounding towards negative infinity, though different from most languages, adds consistency. For instance, it means that the equation <code>(a + b)//b == a//b + 1</code> is always true. It also means that the equation <code>b*(a//b) + a%b == a</code> is valid for both positive and negative values of <code>a</code>. However, maintaining the validity of this equation means that while the result of <code>a%b</code> is, as expected, in the [[half-open interval]] [0, ''b''), where <code>b</code> is a positive integer, it has to lie in the interval (''b'', 0] when <code>b</code> is negative.<ref name="AutoNT-62" />

Python provides a <code>round</code> function for [[rounding]] a float to the nearest integer. For [[Rounding#Tie-breaking|tie-breaking]], versions before 3 use round-away-from-zero: <code>round(0.5)</code> is 1.0, <code>round(-0.5)</code> is −1.0.<ref name="AutoNT-63" /> Python 3 uses [[round to even]]: <code>round(1.5)</code> is 2, <code>round(2.5)</code> is 2.<ref name="AutoNT-64" />

Python allows boolean expressions with multiple equality relations in a manner that is consistent with general use in mathematics. For example, the expression <code>a < b < c</code> tests whether <code>a</code> is less than <code>b</code> and <code>b</code> is less than <code>c</code>. C-derived languages interpret this expression differently: in C, the expression would first evaluate <code>a < b</code>, resulting in 0 or 1, and that result would then be compared with <code>c</code>.<ref name="AutoNT-65" />{{Page needed|date=January 2012}}

Python has extensive built-in support for [[arbitrary precision arithmetic]]. Integers are transparently switched from the machine-supported maximum fixed-precision (usually 32 or 64 bits), belonging to the python type <code>int</code>, to arbitrary precision, belonging to the python type <code>long</code>, where needed. The latter have an "L" suffix in their textual representation.<ref>{{cite web|title = Built-in Type|url = https://docs.python.org/2.7/library/stdtypes.html|website = docs.python.org}}</ref> (In Python 3, the distinction between the <code>int</code> and <code>long</code> types was eliminated; this behavior is now entirely contained by the <code>int</code> class.) The <code>Decimal</code> type/class in module <code>decimal</code> (since version 2.4) provides decimal floating point numbers to arbitrary precision and several rounding modes.<ref>{{cite web|title = PEP 0327 -- Decimal Data Type|url = https://www.python.org/dev/peps/pep-0327/|website = Python.org|accessdate = 26 September 2015|last = Batista|first = Facundo}}</ref> The <code>Fraction</code> type in module <code>fractions</code> (since version 2.6) provides arbitrary precision for rational numbers.<ref>{{cite web|title = What’s New in Python 2.6 — Python v2.6.9 documentation|url = https://docs.python.org/2.6/whatsnew/2.6.html|website = docs.python.org|accessdate = 26 September 2015}}</ref>

Due to Python's extensive mathematics library, and the third-party library [[NumPy]] that further extends the native capabilities, it is frequently used as a scientific scripting language to aid in problems such as numerical data processing and manipulation.
Return to Python (programming language).
					
						Retrieved from "https://en.wikipedia.org/wiki/Python_(programming_language)"					
								
							
		
		
			Navigation menu
			
									
						Personal tools
						
							Not logged inTalkContributionsCreate accountLog in						
					
									
										
						Namespaces
						
							ArticleTalk						
					
										
												
						
							Variants
						
						
							
															
						
					
									
				
										
						Views
						
							ReadEditView history						
					
										
						
						More
						
							
															
						
					
										
						
							Search
						
						
							
															
						
					
									
			
			
				
						
			Navigation
			
								
					Main pageContentsFeatured contentCurrent eventsRandom articleDonate to WikipediaWikipedia store				
							
		
			
			Interaction
			
								
					HelpAbout WikipediaCommunity portalRecent changesContact page				
							
		
			
			Tools
			
								
					What links hereRelated changesUpload fileSpecial pagesPage informationWikidata item				
							
		
			
			Languages
			
								
									
							
		
				
		
				
						
								Privacy policy
								About Wikipedia
								Disclaimers
								Contact Wikipedia
								Developers
								Cookie statement
								Mobile view
							
										
										
											
										
											
									
						
		
		(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":129,"wgHostname":"mw1268"});});
	

